Microsoft (R) Macro Assembler Version 6.14.8444		    04/14/17 11:32:11
BIOS_Next186.asm					     Page 1 - 1


				; This file is part of the Next186 SoC PC project
				; http://opencores.org/project,next186

				; Filename: BIOS_Next186.asm
				; Description: Part of the Next186 SoC PC project, ROM BIOS code
				; Version 1.0
				; Creation date: Feb-Jun 2013

				; Author: Nicolae Dumitrache 
				; e-mail: ndumitrache@opencores.org

				; -------------------------------------------------------------------------------------
				 
				; Copyright (C) 2013 Nicolae Dumitrache
				 
				; This source file may be used and distributed without 
				; restriction provided that this copyright statement is not 
				; removed from the file and that any derivative work contains 
				; the original copyright notice and the associated disclaimer.
				 
				; This source file is free software; you can redistribute it 
				; and/or modify it under the terms of the GNU Lesser General 
				; Public License as published by the Free Software Foundation;
				; either version 2.1 of the License, or (at your option) any 
				; later version. 
				 
				; This source is distributed in the hope that it will be 
				; useful, but WITHOUT ANY WARRANTY; without even the implied 
				; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
				; PURPOSE. See the GNU Lesser General Public License for more 
				; details. 
				 
				; You should have received a copy of the GNU Lesser General 
				; Public License along with this source; if not, download it 
				; from http://www.opencores.org/lgpl.shtml 
				 
				; -----------------------------------------------------------------------

				; Additional Comments: 
				; Assembled with MASM v6.14.8444
				; Next186 SoC PC have no ROM, only RAM. The bootstrap code is the initial value of cache 
				;  (last half 1K = 4 lines of 256bytes each), initially marked as "dirty", in order to
				;  be saved in RAM at first flush
				; The bootstrap code may load the BIOS from SD, or from RS232, and place it at F000:E000



				.186
				.model tiny
 0000				.code

 = 0001				SCANCODE1   equ 1

				;-------------------------- BIOS data area (BDA) -----------------
				;40:0000   2  Base port address of first RS-232 adapter (COM1) See COM Ports
				;40:0002   2  Port of COM2
				;40:0004   2  Port of COM3
				;40:0006   2  Port of COM4
				;40:0008   2  Base port addr of first parallel printer (LPT1)  Printer Ports
				;40:000A   2  Port of LPT2
				;40:000C   2  Port of LPT3
				;40:000E   2  Port of LPT4
				;40:0010   2  Equipment/hardware installed/active; see Equipment List
				;40:0012   1  Errors in PCjr infrared keyboard link
				;40:0013   2  Total memory in K-bytes (same as obtained via INT 12H)
				;40:0015   2  Scratch pad for manufacturing error tests
				;
				;40:0017   2  Keyboard status bits; see Keyboard Shift Status Flags
				;40:0019   1  Current (accumulating) value of Alt+numpad pseudo-key input;
				;             normally 0.  When [Alt] is released, value is stored in
				;             keyboard buffer at 001e.
				;40:001a   2  Addr of keyboard buffer head (keystroke at that addr is next)
				;40:001c   2  Address of keyboard buffer tail
				;40:001e  32  Keyboard buffer.  BIOS stores keystrokes here (head and tail
				;             point to addresses from 041eH to 043dH inclusive).
				;
				;40:003e   1  Diskette drive needs recalibration (bit 0=A, bit 1=B, etc.)
				;             bits 4-5 indicate which drive is currently selected
				;40:003f   1  Diskette motor is running (bit 0=drive A, bit 1=B, etc.)
				;40:0040   1  Time until motor off. INT 08H turns motor off when this is 0.
				;40:0041   1  Diskette error status; same as status returned by INT 13H
				;40:0042   7  Diskette controller status information area
				;
				;40:0049   1  Current active video mode.  See Video Modes and INT 10H.
				;40:004a   2  Screen width in text columns
				;40:004c   2  Length (in bytes) of video area (regen size)
				;40:004e   2  Offset from video segment of active video memory page
				;40:0050  16  Cursor location (8 byte-pairs; low byte=clm, hi byte=row)
				;40:0060   2  Cursor size/shape.  Low byte=end scan line; hi byte=start line.
				;40:0062   1  Current active video page number
				;40:0063   2  Port address for 6845 video controller chip; see CGA I/O Ports
				;40:0065   1  Current value of 6845 video ctrlr CRT_MODE (port 3x8H register)
				;40:0066   1  Current value of 6845 video ctrlr CRT_PALETTE (port 3x9H reg)
				;
				;40:0067   5  Cassette data area or POST data area
				;               40:0067: 1 byte mouse buffer counter (DataCounter)
				;               40:0068: 1 byte mouse packet size (PacketSize): 0 for 3 bytes, 1 for 4 bytes (Intellimouse)
				;               40:0069: 1 byte palette paging status
				;               40:006a: 1 byte PalPagingCounter - guards pal paging re-entrance
				;
				;40:006c   4  Timer tick counter (count of 55ms ticks since CPU reset)
				;40:0070   1  Timer overflow flag (timer has rolled over 24 hr)
				;40:0071   1  Ctrl-Break flag.  Bit 7=1 when break was pressed.  This never
				;             gets reset unless you do it yourself.
				;
				;40:0072   2  1234H means Ctrl+Alt+Del reboot is in progress.  BIOS checks
				;             this to avoid doing a "cold boot" with the time-consuming POST
				;             4321H means reset, preserving memory
				;             5678H, 9abcH, and abcdH (are internal PC Convertible codes)
				;
				;40:0074   4  PCjr diskette or AT hard disk control area
				;  (0074)   1 Status of last fixed-disk drive operation
				;  (0075)   1 Number of hard disk drives for AT
				;  (0077)   1 Hard disk port for XT.  See XT Hard Disk Ports.
				;40:0078   4  Printer time-out values (478H=Lpt1, 478H=Lpt2...)
				;40:007c   4  RS-232 time-out values  (47cH=Com1, 47dH=Com2...)
				;
				;40:0080   2  AT PS/2 keyboard buffer offset start address (usually 01eH)
				;40:0082   2                                   end address (usually 003eH)
				;
				;40:0084   1  EGA text rows-1  (maximum valid row value)
				;40:0085   2  EGA bytes per character (scan-lines/char used in active mode)
				;40:0087   1  EGA flags; see EgaMiscInfoRec
				;40:0088   1  EGA flags; see EgaMiscInfo2Rec
				;40:0089   1  VGA flags; see VgaFlagsRec
				;             See also:  EGA/VGA Data Areas
				;
				;40:008b   1  AT PS/2 Media control: data rate, step rate
				;40:008c   1  AT PS/2 Hard disk drive controller status
				;40:008d   1  AT PS/2 Hard disk drive error status
				;40:008e   1  AT PS/2 Hard disk drive interrupt control
				;
				;40:0090   1  AT PS/2 Disk media state bits for drive 0
				;40:0091   1                                for drive 1
				;40:0092   1  AT PS/2 Disk operation started flag for drive 0
				;40:0093   1                                      for drive 1

				;40:0094   1  AT PS/2 Present cylinder number for drive 0
				;40:0095   1                                  for drive 1
				        ; 2 - Number of 512bytes sectors of HD0
				;
				;40:0096   1  AT Keyboard flag bit 4=1 (10H) if 101-key keyboard is attached
				;40:0097   1  AT Keyboard flag for LED 'key lock' display
				;             bits 0-2 are ScrollLock, NumLock, CapsLock
				;
				;40:0098   4  AT Pointer to 8-bit user wait flag; see INT 15H 86H
				;40:009c   4  AT Microseconds before user wait is done
				;40:00a0   1  AT User wait activity flag:
				;                01H=busy, 80H=posted, 00H=acknowledged
				;
				;40:00a1   7  AT Reserved for network adapters
				;               40:00a1: 4 bytes far pointer to mouse callback (HandlerPtr)
				;               40:00a5: 3 bytes mouse buffer (DataBuffer)
				;
				;40:00a8   4  EGA Address of table of pointers; see EgaSavePtrRec
				;40:00ac  68  Reserved
				;40:00f0  16  (IAC) Inter-Aapplication Communication area.  Programs may use
				;             this area to store status, etc.  Might get overwritten by
				;             another program.

				; http://www.ctyme.com/intr/int.htm

				; video memory: 8 physical segments at 0a000h, 0b000h, 0c000h, 0d000h, 0e000h, 0f000h, 10000h, 11000h
				; Memory segments mapping
				; 1Mb virtual seg address   physical seg address
				;       0000h                   0000h
				;       1000h                   1000h
				;       2000h                   2000h
				;       3000h                   3000h
				;       4000h                   4000h
				;       5000h                   5000h
				;       6000h                   6000h
				;       7000h                   7000h
				;       8000h                   8000h
				;       9000h                   9000h
				;       a000h                   a000h       - video
				;       b000h                   b000h       - video
				;       c000h                   12000h
				;       d000h                   13000h
				;       e000h                   14000h
				;       f000h                   15000h


 = 0100				RAMSize   equ    100h        ; 64KB segments

				        org 0e000h
 E000				bios:        
 E000 4E 65 78 74 31 38		biosmsg     db 'Next186 Nexys4 SoC PC BIOS (C) 2015 Nicolae Dumitrache', 0
       36 20 4E 65 78 79
       73 34 20 53 6F 43
       20 50 43 20 42 49
       4F 53 20 28 43 29
       20 32 30 31 35 20
       4E 69 63 6F 6C 61
       65 20 44 75 6D 69
       74 72 61 63 68 65
       00
 E037 4D 42 20 53 44 20		msgmb       db 'MB SD Card', 13, 10, 0
       43 61 72 64 0D 0A
       00
 E044 50 53 32 20 4B 42		msgkb       db 'PS2 KB detected', 13, 10, 0
       20 64 65 74 65 63
       74 65 64 0D 0A 00


				; Graphics character set
 E056				font8x8:         ; TODO define and place font
 E056				font8x16:        ; TODO define and place font
				        
				        org 0e05bh
 E05B				coldboot:
 E05B				warmboot:
 E05B  FA			        cli
 E05C  FC			        cld
 E05D  B8 0030			        mov     ax, 30h
 E060  8E D0			        mov     ss, ax
 E062  BC 0100			        mov     sp, 100h
				        
 E065  6A 00			        push    0
 E067  9D			        popf
				        
 E068  B0 36			        mov     al, 36h
 E06A  E6 43			        out     43h, al
 E06C  33 C0			        xor     ax, ax
 E06E  E6 40			        out     40h, al
 E070  E6 40			        out     40h, al      ; 18Hz PIT CH0
 E072  E6 61			        out     61h, al      ; speaker off
 E074  F6 D0			        not     al
 E076  E6 21			        out     21h, al      ; disable all interrupts
 E078  E6 A1					out		0a1h, al
				        

				; ------------------ MAP init
 E07A  E8 14CF			        call    flush
 E07D  B8 0015			        mov     ax, 15h     ; BIOS physical segment 15h mapped on virtual segment 0ch
 E080  E7 8C			        out     8ch, ax
 E082  68 C000			        push    0c000h
 E085  07			        pop     es
 E086  68 F000			        push    0f000h
 E089  1F			        pop     ds
 E08A  33 F6			        xor     si, si
 E08C  33 FF			        xor     di, di
 E08E  B9 8000			        mov     cx, 8000h
 E091  F3/ A5			        rep     movsw       ; copy BIOS virtual segment 0fh over physical segment 15h

 E093  E8 14B6			        call    flush
 E096  BA 0080			        mov     dx, 80h      
 E099  33 C0			        xor     ax, ax
 E09B				mapi:        
 E09B  EF			        out     dx, ax
 E09C  40			        inc     ax
 E09D  42			        inc     dx
 E09E  3C 0C			        cmp     al, 0ch
 E0A0  75 02			        jne     short mapi1
 E0A2  04 06			        add     al, 6
 E0A4				mapi1:        
 E0A4  3C 16			        cmp     al, 16h
 E0A6  75 F3			        jne     short mapi
				        
				; -------------------- Interrupt table init
 E0A8  6A 00			        push    0
 E0AA  1F			        pop     ds
 E0AB  1E			        push    ds
 E0AC  07			        pop     es
 E0AD  33 F6			        xor     si, si
 E0AF  BF 0004			        mov     di, 4
 E0B2  C7 04 F54B R		        mov     word ptr [si], offset defint
 E0B6  8C 4C 02			        mov     word ptr [si+2], cs
 E0B9  B9 00FE			        mov     cx, 256-2
 E0BC  F3/ A5			        rep     movsw
 E0BE  C7 06 001C E2EC R	        mov     word ptr ds:[7*4], offset int07
 E0C4  C7 06 0020 E31C R	        mov     word ptr ds:[8*4], offset int08
 E0CA  C7 06 0024 E362 R	        mov     word ptr ds:[9*4], offset int09
 E0D0  C7 06 0040 E581 R	        mov     word ptr ds:[10h*4], offset int10        
 E0D6  C7 06 0044 EDBC R	        mov     word ptr ds:[11h*4], offset int11        
 E0DC  C7 06 0048 EDC5 R	        mov     word ptr ds:[12h*4], offset int12        
 E0E2  C7 06 004C EDCE R	        mov     word ptr ds:[13h*4], offset int13        
 E0E8  C7 06 0050 EFBB R	        mov     word ptr ds:[14h*4], offset int14        
 E0EE  C7 06 0054 F10C R	        mov     word ptr ds:[15h*4], offset int15
 E0F4  C7 06 0058 F2A4 R	        mov     word ptr ds:[16h*4], offset int16
 E0FA  C7 06 0060 F38F R	        mov     word ptr ds:[18h*4], offset int18
 E100  C7 06 0064 F40E R	        mov     word ptr ds:[19h*4], offset int19
 E106  C7 06 0068 F428 R	        mov     word ptr ds:[1ah*4], offset int1a
 E10C  C7 06 01C0 F454 R	        mov     word ptr ds:[70h*4], offset int70
 E112  C7 06 01D0 F47C R	        mov     word ptr ds:[74h*4], offset int74

				; ------------------- BDA init
 E118  6A 40			        push    40h
 E11A  1F			        pop     ds
 E11B  1E			        push    ds
 E11C  07			        pop     es
 E11D  33 FF			        xor     di, di
 E11F  33 F6			        xor     si, si
 E121  33 C0			        xor     ax, ax
 E123  B1 80			        mov     cl, 80h
 E125  F3/ AB			        rep     stosw
 E127  C7 04 03F8				mov		word ptr [si+00h], 3f8h	 ; COM1 base port address
 E12B  C7 44 08 0378				mov		word ptr [si+08h], 378h	 ; LPT1 base port address
 E130  C6 44 10 24		        mov     byte ptr [si+10h], 24h   ; equipment word (color 80x25, PS2 mouse present)
 E134  C7 44 13 0280		        mov     word ptr [si+13h], 640   ; memory size in KB
 E139  83 44 1A 1E		        add     word ptr [si+1ah], 1eh   ; next char pointer in kb buffer
 E13D  83 44 1C 1E		        add     word ptr [si+1ch], 1eh   ; last char pointer in kb buffer
 E141  C7 44 60 0E0F		        mov     word ptr [si+60h], 0e0fh ; cursor shape
 E146  C7 44 63 03D4		        mov     word ptr [si+63h], 3d4h  ; video port address
 E14B  83 84 0080 1E		        add     word ptr [si+80h], 1eh   ; start kb buffer
 E150  83 84 0082 3E		        add     word ptr [si+82h], 3eh   ; end kb buffer
 E155  C7 84 0087 0940		        mov     word ptr [si+87h], 0940h ; video adapter options (512Kb video)
 E15B  C7 84 0089 0B71		        mov     word ptr [si+89h], 0b71h ; VGA video flags: 400 line text mode, default palette loading on (0), blinking on
 E161  C6 84 0096 10		        mov     byte ptr [si+96h], 10h   ; 101 keyboard installed
				 
				; ------------------- Graph mode init
 E166  B8 0003			        mov     ax, 3
 E169  CD 10			        int     10h

				 ; ------------------- KB init ----------------
 E16B  B0 AE			        mov     al, 0aeh
 E16D  E6 64			        out     64h, al     ; enable kb
 E16F  B0 A7			        mov     al, 0a7h
 E171  E6 64			        out     64h, al     ; disable mouse
 E173  B9 0019			        mov     cx, 25
 E176				kbi1:       
 E176  E8 139B			        call    getps2byte
 E179  E2 FB			        loop    short kbi1  ; wait for kb timeout
 E17B  B4 FF			        mov     ah, 0ffh    ; reset kb
 E17D  F8			        clc                 ; kb command
 E17E  E8 13AD			        call    sendcmd   
 E181  72 31			        jc      short nokb
 E183  B1 19			        mov     cl, 25
 E185				kbi2:        
 E185  49			        dec     cx
 E186  E3 2C			        jcxz    short nokb
 E188  E8 1389			        call    getps2byte
 E18B  72 F8			        jc      short kbi2  ; wait for BAT
 E18D  3C AA			        cmp     al, 0aah
 E18F  75 23			        jne     short nokb
 E191  B4 F2			        mov     ah, 0f2h    ; kb id
 E193  E8 1398			        call    sendcmd     ; CF = 0
 E196  72 1C			        jc      short nokb
 E198  E8 1379			        call    getps2byte
 E19B  3C AB			        cmp     al, 0abh
 E19D  75 15			        jne     short nokb
 E19F  E8 1372			        call    getps2byte
 E1A2  3C 83			        cmp     al, 83h
				; set scan code 1
				IFDEF SCANCODE1
 E1A4  75 0E			        jne     short nokb
 E1A6  B4 F0			        mov     ah, 0f0h    ; kb scan set
 E1A8  E8 1383			        call    sendcmd   
 E1AB  72 07			        jc      short nokb
 E1AD  B4 01			        mov     ah, 1       ; scan set 1
 E1AF  E8 137C			        call    sendcmd   
 E1B2  73 05			        jnc     short kbok
				ELSE
				ENDIF        

 E1B4				nokb:   
 E1B4  C6 06 0096 00		        mov     byte ptr KbdFlags3, 0   ; kb not present
 E1B9				kbok:
 E1B9  B0 AD			        mov     al, 0adh
 E1BB  E6 64			        out     64h, al      ; disable kb interface

				; ------------------- Mouse init ----------------
 E1BD  B0 A8			        mov     al, 0a8h
 E1BF  E6 64			        out     64h, al      ; enable mouse
 E1C1				mousei0:        
 E1C1  E8 1350			        call    getps2byte
 E1C4  73 FB			        jnc     short mousei0
 E1C6  B4 FF			        mov     ah, 0ffh
 E1C8  E8 1363			        call    sendcmd      ; reset mouse (CF = 1)
 E1CB  72 15			        jc      short nomouse
 E1CD  B1 19			        mov     cl, 25
 E1CF				mousei1:        
 E1CF  49			        dec     cx
 E1D0  E3 10			        jcxz    short nomouse
 E1D2  E8 133F			        call    getps2byte
 E1D5  72 F8			        jc      short mousei1
 E1D7  3C AA			        cmp     al, 0aah     ; BAT
 E1D9  75 07			        jne     short nomouse
 E1DB  E8 1336			        call    getps2byte
 E1DE  3C 00			        cmp     al, 0        ; mouse ID
 E1E0  74 09			        je      short mouseok
 E1E2				nomouse:
 E1E2  B0 A7			        mov     al, 0a7h        
 E1E4  E6 64			        out     64h, al      ; disable mouse
 E1E6  80 26 0010 FB		        and     byte ptr EquipmentWord, not 4 ; ps2 mouse not present in equipement word
 E1EB				mouseok:
 E1EB  E8 1351			        call    enableKbIfPresent

 E1EE  B0 20			        mov     al, 20h
 E1F0  E6 64			        out     64h, al
 E1F2  E4 60			        in      al, 60h
 E1F4  0C 03			        or      al, 3
 E1F6  8A E0			        mov     ah, al
 E1F8  B0 60			        mov     al, 60h
 E1FA  E6 64			        out     64h, al
 E1FC  8A C4			        mov     al, ah
 E1FE  E6 60			        out     60h, al     ; enable 8042 mouse and kb interrupts

 E200  B8 03E7			        mov     ax,1000-1   ; 1ms
 E203  E7 70			        out     70h, ax     ; set RTC frequency

 E205  B0 00			        mov     al, 0
 E207  E6 21			        out     21h, al     ; enable all PIC interrupts (8h, 9h, 0ch)
 E209  E6 A1					out		0a1h, al	; enable all PIC interrupts (70h, 74h)
 E20B  40					inc		ax
 E20C  E7 01					out		1, ax		; enable auto flush on vblank
 E20E  FB			        sti                 ; enable CPU interrupts

				; ---------------------   HDD init
 E20F  E8 1528			        call    sdinit
 E212  A3 0094			        mov     HDSize, ax
 E215  0E			        push    cs
 E216  07			        pop     es
 E217  BE E000 R		        mov     si, offset biosmsg
 E21A  E8 136D			        call    prts
 E21D  BE E26E R		        mov     si, offset bioscont
 E220  E8 1367			        call    prts
 E223  A1 0094			        mov     ax, HDSize
 E226  D1 E8			        shr     ax, 1
 E228  E8 1346			        call    dispAX
 E22B  BE E037 R		        mov     si, offset msgmb
 E22E  E8 1359			        call    prts
 E231  F6 06 0096 10		        test    byte ptr KbdFlags3, 10h
 E236  74 06			        jz      nokbmsg
 E238  BE E044 R		        mov     si, offset msgkb
 E23B  E8 134C			        call    prts
 E23E				nokbmsg:
 E23E  F6 06 0010 04		        test    byte ptr EquipmentWord, 4
 E243  74 06			        jz      nomousemsg
 E245  BE E259 R		        mov     si, offset msgmouse
 E248  E8 133F			        call    prts
 E24B				nomousemsg:

				;-------------- HD bootstrap
 E24B  B8 00E3					mov		ax, 00e3h
 E24E  CD 14					int		14h		; init COM to 9.6K, 8n1
 E250  B8 0305			        mov     ax, 305h
 E253  33 DB			        xor     bx, bx
 E255  CD 16			        int     16h     ; set typematic rate and delay to fastest
 E257  CD 19			        int     19h

 E259 50 53 32 20 4D 6F		msgmouse    db 'PS2 Mouse detected', 13, 10, 0        
       75 73 65 20 64 65
       74 65 63 74 65 64
       0D 0A 00
 E26E 0D 0A 43 50 55 3A		bioscont    db 13, 10, 'CPU: 80186 80Mhz (80MIPS, 160Mhz 32bit bus)', 13, 10
       20 38 30 31 38 36
       20 38 30 4D 68 7A
       20 28 38 30 4D 49
       50 53 2C 20 31 36
       30 4D 68 7A 20 33
       32 62 69 74 20 62
       75 73 29 0D 0A
 E29D  52 41 4D 3A 20 31	            db 'RAM: 16MB 16bit CRAM 110Mhz', 13, 10
       36 4D 42 20 31 36
       62 69 74 20 43 52
       41 4D 20 31 31 30
       4D 68 7A 0D 0A
 E2BA  43 61 63 68 65 3A	            db 'Cache: 16KB, 4-way, 256x64 bytes data/inst', 13, 10
       20 31 36 4B 42 2C
       20 34 2D 77 61 79
       2C 20 32 35 36 78
       36 34 20 62 79 74
       65 73 20 64 61 74
       61 2F 69 6E 73 74
       0D 0A
 E2E6  48 44 30 3A 20 00	            db 'HD0: ', 0

				; ---------------------------- INT 07 ---------------------
 E2EC				int07 proc near ; coprocessor ESC sequence
 E2EC  50			        push    ax
 E2ED  53			        push    bx
 E2EE  1E			        push    ds
 E2EF  55			        push    bp
 E2F0  8B EC			        mov     bp, sp
 E2F2  C5 5E 08			        lds     bx, [bp+8]  
 E2F5				int07_pfx:        
 E2F5  8A 07			        mov     al, [bx]
 E2F7  43			        inc     bx
 E2F8  24 F8			        and     al, 0f8h
 E2FA  3C D8			        cmp     al, 0d8h        ; ESC code
 E2FC  75 F7			        jne     short int07_pfx
				              
 E2FE  80 3F C0			        cmp     byte ptr [bx], 0c0h ; mod reg r/m of ESC 8087 instruction
 E301  1A C0			        sbb     al, al
 E303  22 07			        and     al, [bx]
 E305  25 00C7			        and     ax, 0c7h
 E308  3C 06			        cmp     al, 6
 E30A  75 02			        jne     int072
 E30C  B0 80			        mov     al, 80h
 E30E				int072:
 E30E  C0 E8 06			        shr     al, 6
 E311  40			        inc     ax
 E312  03 C3			        add     ax, bx
 E314  89 46 08			        mov     [bp+8], ax
 E317  5D			        pop     bp
 E318  1F			        pop     ds
 E319  5B			        pop     bx
 E31A  58			        pop     ax
 E31B  CF			        iret
 E31C				int07 endp


				; ---------------------------- INT 08 ---------------------
 E31C				int08 proc near
 E31C  1E			        push    ds
 E31D  53			        push    bx
 E31E  6A 40			        push    40h
 E320  1F			        pop     ds
 E321  BB 006C			        mov     bx, 6ch
 E324  83 07 01			        add     word ptr [bx], 1
 E327  83 57 02 00		        adc     word ptr [bx+2], 0
 E32B  83 7F 02 18		        cmp     word ptr [bx+2], 18h
 E32F  75 13			        jne     short int081
 E331  81 3F 00B0		        cmp     word ptr [bx], 0b0h
 E335  75 0D			        jne     short int081
 E337  C7 07 0000		        mov     word ptr [bx], 0
 E33B  C7 47 02 0000		        mov     word ptr [bx+2], 0
 E340  C6 47 04 01		        mov     byte ptr [bx+4], 1
 E344				int081:
 E344  CD 1C			        int     1ch
 E346  FB			        sti
 E347  50			        push    ax
 E348  B4 04			        mov     ah, 4
 E34A				kloop:        
 E34A  E4 64			        in      al, 64h
 E34C  A8 01			        test    al, 1
 E34E  74 0E			        jz      short nokey
 E350  FE CC			        dec     ah
 E352  75 F6			        jnz     short kloop
 E354  A8 20			        test    al, 20h
 E356  74 04			        jz      short kbdata
 E358  CD 74			        int     74h
 E35A  EB 02			        jmp     short nokey
 E35C				kbdata:
 E35C  CD 09			        int     9h        
 E35E				nokey:
 E35E  58			        pop     ax
 E35F  5B			        pop     bx
 E360  1F			        pop     ds
 E361  CF			        iret
 E362				int08 endp

				; --------------------- INT 09 - keyboard ------------------
 = ds:[17h]			KbdFlags1       equ     <ds:[17h]>
 = ds:[18h]			KbdFlags2       equ     <ds:[18h]>
 = ds:[19h]			AltKpd          equ     <ds:[19h]>
 = ds:[71h]			CtrlBreak       equ     <ds:[71h]>
 = ds:[96h]			KbdFlags3       equ     <ds:[96h]>
 = ds:[97h]			KbdFlags4       equ     <ds:[97h]>

				; Bits for the KbdFlags1
 = 0001				RShfDown        equ     1
 = 0002				LShfDown        equ     2
 = 0004				CtrlDown        equ     4
 = 0008				AltDown         equ     8
 = 0010				ScrLock         equ     10h
 = 0020				NumLock         equ     20h
 = 0040				CapsLock        equ     40h
 = 0080				Insert          equ     80h

				; Bits for the KbdFlags2
 = 0001				LCtrDown        equ     1
 = 0002				LAltDown        equ     2
 = 0004				SysReqDown      equ     4
 = 0008				Pause           equ     8
 = 0010				ScrLockDown     equ     10h
 = 0020				NumLockDown     equ     20h
 = 0040				CapsLockDown    equ     40h
 = 0080				InsDown         equ     80h
				 
				; Bits for the KbdFlags3
 = 0001				LastE1          equ     1
 = 0002				LastE0          equ     2
 = 0004				RCtrDown        equ     4
 = 0008				RAltDown        equ     8
 = 0020				LastF0          equ     20h

				; Bits for the KbdFlags4
 = 0001				ScrLockLED      equ     1
 = 0002				NumLockLED      equ     2
 = 0004				CapsLockLED     equ     4
 = 0008				SetRepeat       equ     8       ; Set auto repeat command in progress
 = 0010				AckReceived     equ     10h
 = 0040				LEDUpdate       equ     40h

				IFDEF SCANCODE1

 E362				int09 proc near
 E362  60			        pusha
 E363  1E			        push    ds
 E364  06			        push    es
 E365  6A 40			        push    40h
 E367  1F			        pop     ds
 E368  E4 60			        in      al, 60h         ; al contains the scan code
 E36A  8B 16 0017		        mov     dx, KbdFlags1
 E36E  8B 0E 0096		        mov     cx, KbdFlags3
 E372  3C FA			        cmp     al, 0fah        ; ACK
 E374  75 1F			        jne     short noACK
				; ------------ manage ACK response
 E376  F6 C5 40			        test    ch, LEDUpdate
 E379  74 14			        jz      short ToggleACK ; no LED update
 E37B  F6 C5 10			        test    ch, AckReceived
 E37E  75 0C			        jnz     short SecondACK ; second ACK received
 E380  8A E5			        mov     ah, ch          ; LED update command sent, ACK received, need to send second byte
 E382  80 E4 07			        and     ah, ScrLockLED or NumLockLED or CapsLockLED
 E385  B3 00			        mov     bl, 0
 E387  E8 1165			        call    sendps2byte
 E38A  EB 03			        jmp     short ToggleACK
 E38C				SecondACK:        
 E38C  80 F5 40			        xor     ch, LEDUpdate   ; second ACK, clear LED update bit
 E38F				ToggleACK:
 E38F  80 F5 10			        xor     ch, AckReceived ; toggle ACK bit 
 E392				SetFlags1:                                  
 E392  E9 01AF			        jmp     SetFlags               
				        
				; ------------ no ACK
 E395				noACK:
 E395  B4 4F			        mov     ah,4fh
 E397  F9			        stc
 E398  CD 15			        int     15h
 E39A  72 03 E9 01C8		        jnc     int09Exit
 E39F  3C E0			        cmp     al, 0e0h
 E3A1  75 05			        jne     short noE0
 E3A3  80 C9 02			        or      cl, LastE0
 E3A6  EB EA			        jmp     short SetFlags1
 E3A8				noE0:
 E3A8  3C E1			        cmp     al, 0e1h
 E3AA  75 05			        jne     short noE1
 E3AC  80 C9 01			        or      cl, LastE1
 E3AF  EB E1			        jmp     short SetFlags1
 E3B1				noE1:   
 E3B1  3C 53			        cmp     al, 53h     ; is DEL?
 E3B3  75 18			        jne     short noDEL
 E3B5  8A E2			        mov     ah, dl
 E3B7  80 E4 0C			        and     ah, CtrlDown or AltDown
 E3BA  80 FC 0C			        cmp     ah, CtrlDown or AltDown
 E3BD  74 03 E9 010F		        jne     NormalKey   ; is DEL, but no CTRL+ALt+DEL
 E3C2  C7 06 0072 1234		        mov     word ptr ds:[72h], 1234h    ; warm boot flag
 E3C8  EA			        db      0eah
 E3C9  0000 FFFF		        dw      0, 0ffffh       ; reboot
 E3CD				noDEL:
 E3CD  F6 C1 02			        test    cl, LastE0
 E3D0  75 24			        jnz     short noRSUp    ; ignore fake shifts
 E3D2  3C 2A			        cmp     al, 2ah         ; left shift
 E3D4  75 05			        jne     short noLSDown
 E3D6  80 CA 02			        or      dl, LShfDown
 E3D9  EB 63			        jmp     short SetFlagsKey2
 E3DB				noLSDown:
 E3DB  3C AA			        cmp     al, 2ah or 80h
 E3DD  75 05			        jne     short noLSUp
 E3DF  80 E2 FD			        and     dl, not LShfDown
 E3E2  EB 5A			        jmp     short SetFlagsKey2
 E3E4				noLSUp:
 E3E4  3C 36			        cmp     al, 36h         ; right shift
 E3E6  75 05			        jne     short noRSDown
 E3E8  80 CA 01			        or      dl, RShfDown
 E3EB  EB 51			        jmp     short SetFlagsKey2
 E3ED				noRSDown:
 E3ED  3C B6			        cmp     al, 36h or 80h
 E3EF  75 05			        jne     short noRSUP
 E3F1  80 E2 FE			        and     dl, not RShfDown
 E3F4  EB 48			        jmp     short SetFlagsKey2
 E3F6				noRSUp:
 E3F6  3C 38			        cmp     al, 38h         ; ALT
 E3F8  75 13			        jne     short noALTDown
 E3FA  F6 C1 02			        test    cl, LastE0
 E3FD  74 08			        jz      short LALTDn
 E3FF  80 C9 08			        or      cl, RAltDown
 E402  80 CA 08			        or      dl, AltDown
 E405  EB 37			        jmp     short SetFlagsKey2
 E407				LALTDn:
 E407  81 CA 0208		        or      dx, (LAltDown shl 8) or AltDown
 E40B  EB 31			        jmp     short SetFlagsKey2
 E40D				noALTDown:
 E40D  3C B8			        cmp     al, 38h or 80h
 E40F  75 1E			        jne     short noALTUp
 E411  F6 C1 02			        test    cl, LastE0
 E414  74 08			        jz      short LALTUp
 E416  80 E1 F7			        and     cl, not RAltDown
 E419  80 E2 F7			        and     dl, not AltDown
 E41C  EB 04			        jmp     short ALTup
 E41E				LALTUp:
 E41E  81 E2 FDF7		        and     dx, not ((LAltDown shl 8) or AltDown)
 E422				ALTUp:
 E422  33 C0			        xor     ax, ax
 E424  86 06 0019		        xchg    al, AltKpd
 E428  84 C0			        test    al, al
 E42A  74 12			        jz      short SetFlagsKey2     
 E42C  E9 0107			        jmp     pushKey
 E42F				noALTUp:
 E42F  3C 1D			        cmp     al, 1dh         ; CTL
 E431  75 13			        jne     short noCTLDown
 E433  F6 C1 02			        test    cl, lastE0
 E436  74 08			        jz      short LCTLDn
 E438  80 C9 04			        or      cl, RCtrDown
 E43B  80 CA 04			        or      dl, CtrlDown
 E43E				SetFlagsKey2:        
 E43E  EB 79			        jmp     short SetFlagsKey1
 E440				LCTLDn:
 E440  81 CA 0104		        or      dx, (LCtrDown shl 8) or CtrlDown
 E444  EB 73			        jmp     short SetFlagsKey1
 E446				noCTLDown:
 E446  3C 9D			        cmp     al, 1dh or 80h
 E448  75 13			        jne     short noCTLUp
 E44A  F6 C1 02			        test    cl, LastE0
 E44D  74 08			        jz      short LCTLUp
 E44F  80 E1 FB			        and     cl, not RCtrDown
 E452  80 E2 FB			        and     dl, not CtrlDown
 E455  EB 62			        jmp     short SetFlagsKey1
 E457				LCTLUp:
 E457  81 E2 FEFB		        and     dx,  not ((LCtrDown shl 8) or CtrlDown)
 E45B  EB 5C			        jmp     short SetFlagsKey1
 E45D				noCTLUp:
 E45D  BB 3A40			        mov     bx, 3a00h + CapsLock
 E460  E8 0108			        call    KeyLock
 E463  73 54			        jnc     short SetFlagsKey1
				        
 E465  BB 4610			        mov     bx, 4600h + ScrLock
 E468  52			        push    dx          ; save ScrLock state bit (dl)
 E469  E8 00FF			        call    KeyLock
 E46C  5B			        pop     bx          ; restore ScrLock state bit (bl)
 E46D  72 21			        jc      short noScrLock
 E46F  F6 C2 04			        test    dl, CtrlDown
 E472  74 45			        jz      short SetFlagsKey1; no break, just ScollLock
 E474  8A D3			        mov     dl, bl      ; restore ScrLock flag
 E476  F6 C7 10			        test    bh, ScrLockDown
 E479  75 3E			        jnz     short SetFlagsKey1 
 E47B  C6 06 0071 80		        mov     byte ptr CtrlBreak, 80h   ; CTRL+BREAK flag
 E480  A1 0080			        mov     ax, Buffer
 E483  A3 001A			        mov     HeadPtr, ax
 E486  A3 001C			        mov     TailPtr, ax
 E489  CD 1B			        int     1bh
 E48B  33 C0			        xor     ax, ax
 E48D  E9 00A6			        jmp     pushkey
 E490				noScrLock:        
 E490  F6 C1 02			        test    cl, LastE0  ; INS
 E493  75 0A			        jnz     short testINS
 E495  F6 C2 03			        test    dl, RShfDown or LShfDown
 E498  75 05			        jnz     short testINS
 E49A  F6 C2 20			        test    dl, NumLock
 E49D  75 06			        jnz     short NoIns      
 E49F				testINS:
 E49F  BB 5280			        mov     bx, 5200h + Insert
 E4A2  E8 00C6			        call    KeyLock  
 E4A5				noIns:
 E4A5  BB 4520			        mov     bx, 4500h + NumLock
 E4A8  52			        push    dx          ; save NumLock state bit (dl)
 E4A9  E8 00BF			        call    KeyLock
 E4AC  5B			        pop     bx          ; restore NumLock state bit (bl)
 E4AD  72 22			        jc      short NormalKey   ; CTRL+NumLock = Pause
 E4AF  F6 C2 04			        test    dl, CtrlDown
 E4B2  74 05			        jz      short SetFlagsKey1
 E4B4  8A D3			        mov     dl, bl      ; restore NumLock flag
 E4B6  80 CE 08			        or      dh, Pause   ; set Pause bit
 E4B9				SetFlagsKey1:
 E4B9  E9 0085			        jmp     SetFlagsKey
 E4BC				E0Key:
 E4BC  BF FB5A R		        mov     di, offset E0KeyList
 E4BF  51			        push    cx
 E4C0  B9 000C			        mov     cx, E0KeyIndex - E0KeyList
 E4C3  FC			        cld
 E4C4  0E			        push    cs
 E4C5  07			        pop     es
 E4C6  F2/ AE			        repne   scasb
 E4C8  59			        pop     cx
 E4C9  75 76			        jne     short SetFlagsKey
 E4CB  26: 8A 45 0B		        mov     al, es:[di + E0KeyIndex - E0KeyList - 1]
 E4CF  EB 14			        jmp     short KeyDown
 E4D1				NormalKey:
 E4D1  A8 80			        test    al, 80h
 E4D3  75 6C			        jnz     short SetFlagsKey ; key up
 E4D5  F6 C1 02			        test    cl, LastE0
 E4D8  75 E2			        jnz     short E0Key
 E4DA  3C 59			        cmp     al, 59h
 E4DC  1A E4			        sbb     ah, ah
 E4DE  22 C4			        and     al, ah
 E4E0  BB FB01 R		        mov     bx, offset KeyIndex
 E4E3  2E: D7			        xlat    cs:[bx]
 E4E5				KeyDown:
 E4E5  33 DB			        xor     bx, bx 
 E4E7  F6 C2 03			        test    dl, RShfDown or LShfDown
 E4EA  74 02			        jz      short noShift
 E4EC  B3 02			        mov     bl, 2
 E4EE				noShift:
 E4EE  3C 1A			        cmp     al, 26
 E4F0  77 0A			        ja      short noCaps
 E4F2  F6 C2 40			        test    dl, CapsLock
 E4F5  74 13			        jz      short noNum
 E4F7  80 F3 02			        xor     bl, 2
 E4FA  EB 0E			        jmp     short noNum 
 E4FC				noCaps:
 E4FC  3C 25			        cmp     al, 37
 E4FE  77 0A			        ja      short noNum
 E500  F6 C2 20			        test    dl, NumLock
 E503  75 02			        jnz     short NumDown
 E505  B3 02			        mov     bl, 2
 E507				NumDown:
 E507  80 F3 02			        xor     bl, 2
 E50A				noNum:        
 E50A  F6 C2 04			        test    dl, CtrlDown
 E50D  74 02			        jz      short noCtrl
 E50F  B3 04			        mov     bl, 4
 E511				noCtrl:
 E511  F6 C2 08			        test    dl, AltDown
 E514  74 02			        jz      short noAlt
 E516  B3 06			        mov     bl, 6
 E518				noAlt:
 E518  98			        cbw
 E519  C1 E0 03			        shl     ax, 3
 E51C  03 D8			        add     bx, ax
 E51E  2E: 8B 87 FB72 R		        mov     ax, cs:KeyCode[bx]
 E523  83 F8 0A			        cmp     ax, 000ah
 E526  77 0E			        ja      short pushKey
 E528  48			        dec     ax
 E529  78 16			        js      short SetFlagsKey     ; ax was 0
 E52B  8A 26 0019		        mov     ah, AltKpd
 E52F  D5 0A			        aad
 E531  A2 0019			        mov     AltKpd, al
 E534  EB 0B			        jmp     short SetFlagsKey
 E536				pushKey:                
 E536  51			        push    cx
 E537  8B C8			        mov     cx, ax
 E539  B4 05			        mov     ah, 5
 E53B  CD 16			        int     16h
 E53D  59			        pop     cx
 E53E  80 E6 F7			        and     dh, not Pause    ; clear Pause bit
 E541				SetFlagsKey:
 E541  80 E1 FC			        and     cl, not (LastE0 or LastE1)    ; not prefix key code, clear all prefixes
 E544				SetFlags:
 E544  8A C2			        mov     al, dl
 E546  C0 E8 04			        shr     al, 4
 E549  32 C5			        xor     al, ch
 E54B  24 07			        and     al, 7
 E54D  74 10			        jz      short SF1   ; no LEDs to update
 E54F  F6 C5 58			        test    ch, SetRepeat or AckReceived or LEDUpdate
 E552  75 0B			        jnz     short SF1   ; can not update LEDS, so just write the flags and exit
 E554  0C 40			        or      al, LEDUpdate
 E556  32 E8			        xor     ch, al      ; insert the LEDs in KbdFlags4
 E558  B4 ED			        mov     ah, 0edh    ; set LED
 E55A  B3 00			        mov     bl, 0
 E55C  E8 0F90			        call    sendps2byte
 E55F				SF1:        
 E55F  89 16 0017		        mov     KbdFlags1, dx
 E563  89 0E 0096		        mov     KbdFlags3, cx
				        
 E567				int09Exit:
 E567  07			        pop     es
 E568  1F			        pop     ds
 E569  61			        popa
 E56A  CF			        iret
 E56B				int09 endp

				ELSE    ; SCANCODE2
				ENDIF

 E56B				KeyLock proc near   ; input: BH = expected scan code, al = scan code, BL = key lock flag. Returns CF=1 to continue, CF=0 to exit
 E56B  32 F8			        xor     bh, al
 E56D  75 09			        jnz     short s2
 E56F  8A E6			        mov     ah, dh
 E571  0A F3			        or      dh, bl      ; set flag
 E573  32 E6			        xor     ah, dh      ; get flag difference
 E575  32 D4			        xor     dl, ah      ; toggle only if key was not already down
 E577  C3			        ret
 E578  80 FF 80			s2:     cmp     bh, 80h
 E57B  F9			        stc
 E57C  75 02			        jne     short exit
 E57E  32 F3			        xor     dh, bl      ; key up
 E580				exit:
 E580  C3			        ret
 E581				KeyLock endp


				; --------------------- INT 10h - Video ----------------
 = ds:[49h]			ActiveVideoMode     equ <ds:[49h]>  ; 1  byte
 = ds:[4ah]			ScreenWidth         equ <ds:[4ah]>  ; 2  Screen width in text columns
 = ds:[4ch]			RegenLength         equ <ds:[4ch]>  ; 2  Length (in bytes) of video area (regen size)
 = ds:[4eh]			PageOffset          equ <ds:[4eh]>  ; 2  Offset from video segment of active video memory page
 = ds:[50h]			CursorPos           equ <ds:[50h]>  ; 16 Cursor location (8 byte-pairs; low byte=col, hi byte=row)
 = ds:[60h]			CursorShape         equ <ds:[60h]>  ; 2  Cursor size/shape.  Low byte=end scan line; hi byte=start line.
 = ds:[62h]			ActivePage          equ <ds:[62h]>  ; 1  Current active video page number
 = ds:[63h]			PortAddress         equ <ds:[63h]>  ; 2  Port address for 6845 video controller chip; see CGA I/O Ports
 = ds:[65h]			CrtMode             equ <ds:[65h]>  ; 1  Current value of 6845 video ctrlr CRT_MODE (port 3x8H register)
 = ds:[66h]			CrtPalette          equ <ds:[66h]>  ; 1  Current value of 6845 video ctrlr CRT_PALETTE (port 3x9H reg)
 = ds:[84h]			ScreenRows          equ <ds:[84h]>  ; 1  EGA text rows-1  (maximum valid row value)
 = ds:[85h]			ScanLinesChar       equ <ds:[85h]>  ; 2  EGA bytes per character (scan-lines/char used in active mode)
 = ds:[87h]			EgaMiscInfo         equ <ds:[87h]>  ; 1  EGA flags; see EgaMiscInfoRec
 = ds:[88h]			EgaMiscInfo2        equ <ds:[88h]>  ; 1  EGA flags; see EgaMiscInfo2Rec
 = ds:[89h]			VgaFlags            equ <ds:[89h]>  ; 1  VGA flags; see VgaFlagsRec
 = ds:[8ah]			VgaFlags2           equ <ds:[8ah]>  ; 1  VGA flags2
 = ds:[69h]			PalPaging           equ <ds:[69h]>  ; 1  Palette paging status: bit7=0 for 4x64, 1 for 16x16. bit3:0=active page
 = ds:[6ah]			PalPagingCounter    equ <ds:[6ah]>  ; 1  Palette paging counter


 E581				int10 proc near     
 E581  FB			        sti                     ; no interrupt reentrant
 E582  FC			        cld
 E583  1E			        push    ds
 E584  56			        push    si
 E585  6A 40			        push    40h
 E587  1F			        pop     ds
 E588  80 FC 4F			        cmp     ah, 4fh
 E58B  74 16			        je      short svga
 E58D  80 FC 1C			        cmp     ah, 1ch
 E590  77 0E			        ja      short exit
 E592  8B F0			        mov     si, ax
 E594  C1 EE 07			        shr     si, 7
 E597  81 E6 01FE		        and     si, 1feh
 E59B  2E: FF 94 ED82 R		        call    cs:vidtbl[si]
 E5A0				exit:        
 E5A0  5E			        pop     si
 E5A1  1F			        pop     ds
 E5A2  CF			        iret
 E5A3				svga:
 E5A3  3C 05			        cmp     al, 5
 E5A5  74 77			        je      short VESAMemControl
 E5A7  3C 01			        cmp     al, 1
 E5A9  72 0D			        jb      short VESAGetInfo
 E5AB  74 24			        je      short VESAGetModeInfo
 E5AD  3C 03			        cmp     al, 3
 E5AF  72 37			        jb      short VESASetMode
 E5B1  74 4F			        je      short VESAGetMode
 E5B3  B8 0100			        mov     ax, 100h
 E5B6  EB E8			        jmp     short exit

				; ---------------- VESA fn00
 E5B8				VESAGetInfo:
 E5B8  51			        push    cx
 E5B9  57			        push    di
 E5BA  BE E64A R		        mov     si, offset VESAInfo
 E5BD  B9 000A			        mov     cx, 10
 E5C0  F3/ 2E: A5		        rep     movsw es:[di], cs:[si]
 E5C3  B1 76			        mov     cl, 118     ; 236 bytes 0
 E5C5				VESASupportedClear:        
 E5C5  33 C0			        xor     ax, ax
 E5C7  F3/ AB			        rep     stosw
 E5C9  5F			        pop     di
 E5CA  59			        pop     cx     
 E5CB				VESASupported:
 E5CB  B4 00			        mov     ah, 0       ; success    
 E5CD				VESASupportedErr:
 E5CD  B0 4F			        mov     al, 4fh
 E5CF  EB CF			        jmp     short exit

				; ---------------- VESA fn01
 E5D1				VESAGetModeInfo:
 E5D1  81 F9 0101		        cmp     cx, 101h
 E5D5				VESAGetModeInfo1:        
 E5D5  B4 01			        mov     ah, 1       ; error
 E5D7  75 F4			        jne     short VESASupportedErr
 E5D9  51			        push    cx
 E5DA  57			        push    di
 E5DB  B9 0009			        mov     cx, 9
 E5DE  BE E675 R		        mov     si, offset VESAModeInfo
 E5E1  F3/ 2E: A5		        rep     movsw es:[di], cs:[si]
 E5E4  B1 77			        mov     cl, 119       
 E5E6  EB DD			        jmp     short VESASupportedClear

				; ---------------- VESA fn02
 E5E8				VESASetMode:
 E5E8  6B C3 02			        imul    ax, bx, 2
 E5EB  3D 0202			        cmp     ax, 101h*2
 E5EE  75 0A			        jne     short VESASetMode1      
 E5F0  8D 87 23FF		        lea     ax, [bx+23ffh]
 E5F4  86 E0			        xchg    ah, al
 E5F6  CD 10			        int     10h
 E5F8  EB D1			        jmp     short VESASupported   
 E5FA				VESASetMode1:
 E5FA  8A C3			        mov     al, bl
 E5FC  B4 00			        mov     ah, 0
 E5FE  CD 10			        int     10h
 E600  EB C9			        jmp     short VESASupported

				; ---------------- VESA fn03
 E602				VESAGetMode:
 E602  8A 3E 0087		        mov     bh, EgaMiscInfo
 E606  80 E7 80			        and     bh, 80h
 E609  8A 1E 0049		        mov     bl, ActiveVideoMode
 E60D  80 FB 25			        cmp     bl, 25h
 E610  74 06			        je      short VESAGetMode1
 E612  0A DF			        or      bl, bh
 E614  B7 00			        mov     bh, 0
 E616  EB B3			        jmp     short VESASupported
 E618				VESAGetMode1:
 E618  81 C3 00DC		        add     bx, 257-25h        
 E61C  EB AD			        jmp     short VESASupported

				; ---------------- VESA fn05
 E61E				VESAMemControl:
				;        test    bx, not 101h                ; BX validation
				;        jnz     short VESAGetModeInfo1      ; error
 E61E  0E			        push    cs
 E61F  68 E5CB R		        push    offset VESASupported
				;        call    VESAMemControlCB
				;        jmp     short VESASupported
 E622				VESAMemControlCB:
 E622  9C			        pushf
 E623  FA			        cli
 E624  50			        push    ax
 E625  52			        push    dx
 E626  8B C3			        mov     ax, bx
 E628  83 E0 01			        and     ax, 1
 E62B  04 8A			        add     al, 8ah
 E62D  92			        xchg    ax, dx
 E62E  83 E0 07			        and     ax, 7
 E631  04 0A			        add     al, 0ah
 E633  84 FF			        test    bh, bh
 E635  75 08			        jnz     getpageinfo
 E637  E8 0F12			        call    flush
 E63A  EF			        out     dx, ax          
 E63B  5A			        pop     dx
 E63C  58			        pop     ax
 E63D  9D			        popf
 E63E  CB			        retf
 E63F				getpageinfo:
 E63F  ED			        in      ax, dx
 E640  2C 0A			        sub     al, 0ah
 E642  83 E0 07			        and     ax, 7
 E645  92			        xchg    ax, dx
 E646  58			        pop     ax
 E647  58			        pop     ax                
 E648  9D			        popf
 E649  CB			        retf
				   
 E64A 56 45 53 41		VESAInfo    db  'VESA'
 E64E  0100 E65E R F000		            dw  100h, VESAOEM, 0f000h, 2, 0, VESAModes, 0f000h, 8
       0002 0000 E671 R
       F000 0008
 E65E 4E 69 63 6F 6C 61		VESAOEM     db  'Nicolae Dumitrache', 0
       65 20 44 75 6D 69
       74 72 61 63 68 65
       00
 E671 0101 FFFF			VESAModes   dw  101h, 0ffffh
 E675				VESAModeInfo:
				;Bit(s)  Description - mode attributes 
				;0      mode supported by present hardware configuration
				;1      optional information available (must be =1 for VBE v1.2+)
				;2      BIOS output supported
				;3      set if color, clear if monochrome
				;4      set if graphics mode, clear if text mode
				;---VBE v2.0+ ---
				;5      mode is not VGA-compatible
				;6      bank-switched mode not supported
				;7      linear framebuffer mode supported
				;8      double-scan mode available (e.g. 320x200 and 320x240)
				;---VBE v3.0 ---
				;9      interlaced mode available
				;10     hardware supports triple buffering
				;11     hardware supports stereoscopic display
				;12     dual display start address support
				;13-15  reserved
 E675  0099			        dw  0000000010011001b       
				;Bit(s)  Description - window attributes
				;0      exists
				;1      readable
				;2      writable
				;3-7    reserved
 E677  07 07			        db  00000111b, 00000111b
 E679  0040 0040 A000		        dw  64, 64, 0a000h, 0b000h, VESAMemControlCB, 0f000h, 640
       B000 E622 R F000
       0280


				; --------------- fn 00h, set video mode
 E687				setmode:
 E687  60			        pusha
 E688  06			        push    es
 E689  02 C0			        add     al, al      ; CF = cls bit
 E68B  D0 16 0087		        rcl     byte ptr EgaMiscInfo, 1
 E68F  D0 0E 0087		        ror     byte ptr EgaMiscInfo, 1

 E693  50				push	ax
 E694  BA 03C4				mov	dx, 3c4h
 E697  B8 0F02				mov	ax, 0f02h
 E69A  EF				out	dx, ax		; enable all write planes
 E69B  B8 0804				mov	ax, 0804h
 E69E  EF				out	dx, ax		; clear planar mode
 E69F  B2 CE				mov	dl, 0ceh
 E6A1  B8 0001				mov	ax, 0001h
 E6A4  EF				out	dx, ax		; disable set/reset
 E6A5  B8 0003				mov	ax, 0003h
 E6A8  EF				out	dx, ax		; reset logical op and rotate count
 E6A9  B8 0005				mov	ax, 0005h
 E6AC  EF				out	dx, ax		; set write mode to 00 (CPU access)
 E6AD  B8 FF08				mov	ax, 0ff08h
 E6B0  EF				out	dx, ax		; set bitmask to CPU access
 E6B1  58				pop	ax

 E6B2  3C 06			        cmp     al, 3*2
 E6B4  77 32			        ja      short setmode1
 E6B6  B0 B6			        mov     al, 0b6h        ; reset sound generator
 E6B8  E6 43			        out     43h, al
 E6BA  B0 00			        mov     al, 0
 E6BC  E6 42			        out     42h, al
 E6BE  E6 42			        out     42h, al
 E6C0  B8 0806			        mov     ax, 0806h   ; text mode (80x25, 16 colors), flash enabled
 E6C3  C7 06 004A 0050		        mov     word ptr ScreenWidth, 80
 E6C9  C7 06 004C 1000		        mov     word ptr RegenLength, 1000h
 E6CF  C6 06 0084 18		        mov     byte ptr ScreenRows, 25-1
 E6D4  C7 06 0085 0010		        mov     word ptr ScanLinesChar, 16
 E6DA  BB B800			        mov     bx, 0b800h  ; segment
 E6DD  B9 4000			        mov     cx, 4000h   ; video len/2
 E6E0  BE 0720			        mov     si, 0720h   ; clear value
 E6E3  BF BF14			        mov	di, 0bf14h  ; 200lines, 14h offset
 E6E6  EB 72			        jmp     short setmode2
 E6E8				setmode1:
 E6E8  3C 1A				cmp	al, 0dh*2
 E6EA  75 13				jne	short setmode12
 E6EC  BF BF14				mov	di, 0bf14h	; 200 lines, 14h offset
 E6EF  B4 11				mov	ah, 11h		; graphic, 640x480, half
 E6F1  C7 06 004A 0028		        mov     word ptr ScreenWidth, 40
 E6F7  C7 06 004C 2000		        mov     word ptr RegenLength, 2000h
 E6FD  EB 15				jmp	short setmode121
 E6FF				setmode12:	
 E6FF  3C 24				cmp	al, 12h*2
 E701  75 20				jne	short setmode13
 E703  BF 0028				mov	di, 0028h	; 240lines, 28h offset
 E706  B4 01				mov	ah, 1		; graphic, 640x480
 E708  C7 06 004A 0050		        mov     word ptr ScreenWidth, 80
 E70E  C7 06 004C A000		        mov     word ptr RegenLength, 0a000h
 E714				setmode121:
 E714  50				push	ax
 E715  BA 03C4				mov	dx, 3c4h
 E718  B8 FF02				mov	ax, 0ff02h
 E71B  EF				out	dx, ax		; set write all planes
 E71C  B8 0004				mov	ax, 0004h
 E71F  EF				out	dx, ax		; set planar mode
 E720  58				pop	ax
 E721  EB 2F				jmp	short setmode21
 E723				setmode13:    
 E723  3C 26			        cmp     al, 13h*2
 E725  75 13			        jne     short setmode3    
 E727  B4 41			        mov     ah, 41h     ; graphic mode, 320x200, 256 colors
 E729  C7 06 004A 0028		        mov     word ptr ScreenWidth, 40
 E72F  C7 06 004C 0000		        mov     word ptr RegenLength, 0000h
 E735  BF BF28			        mov	di, 0bf28h	; 200 lines, 28h offset
 E738  EB 18			        jmp     short setmode21
 E73A				setmode3:
 E73A  3C 4A			        cmp     al, 25h*2
 E73C  74 03 E9 0096		        jne	setmodeexit
 E741  BF 0050			        mov	di, 0050h	; 240 lines, 50h offset
 E744  B4 01			        mov     ah, 1       ; graphic mode, 640x400, 256 colors
 E746  C7 06 004A 0050		        mov     word ptr ScreenWidth, 80
 E74C  C7 06 004C 0000		        mov     word ptr RegenLength, 0000h
 E752				setmode21:
 E752  BB A000			        mov     bx, 0a000h  ; segment
 E755  B9 8000			        mov     cx, 8000h   ; video len/2
 E758  33 F6			        xor     si, si      ; clear value
 E75A				setmode2:
 E75A  D0 E8			        shr     al, 1
 E75C  A2 0049			        mov     ActiveVideoMode, al
 E75F  50			        push    ax
 E760  51			        push    cx
 E761  1E			        push    ds
 E762  07			        pop     es
 E763  BA 03D4			        mov	dx, 3d4h
 E766  8B C7			        mov	ax, di
 E768  B0 06			        mov	al, 6
 E76A  EF			        out	dx, ax		; set scanlines
 E76B  97			        xchg	ax, di
 E76C  8A E0			        mov	ah, al
 E76E  B0 13			        mov	al, 13h
 E770  EF			        out	dx, ax		; set offset
 E771  33 C0			        xor     ax, ax
 E773  BF 0050			        mov     di, offset CursorPos
 E776  B9 0008			        mov     cx, 8
 E779  F3/ AB			        rep     stosw           ; reset cursor position for all pages
 E77B  B8 0500			        mov     ax, 0500h
 E77E  CD 10			        int     10h             ; set page0
 E780  59			        pop     cx
 E781  F6 06 0087 80		        test    byte ptr EgaMiscInfo, 80h
 E786  75 1D			        jnz     short setmode4    ; no clear video memory

 E788  8E C3			        mov     es, bx
 E78A				clearnext:
 E78A  96			        xchg    ax, si
 E78B  33 FF			        xor     di, di
 E78D  51				push	cx
 E78E  F3/ AB			        rep     stosw        
 E790  59				pop	cx
 E791  80 FF A0				cmp	bh, 0a0h
 E794  75 08				jnz	short clearok
 E796  96				xchg	ax, si
 E797  40				inc	ax
 E798  CD 10				int	10h
 E79A  3C 08				cmp	al, 8
 E79C  75 EC				jnz	short clearnext				
 E79E				clearok:
 E79E  E8 028A			        call    palpageset     
 E7A1  88 0E 0069		        mov     byte ptr PalPaging, cl  ; reset paging        

 E7A5				setmode4:
 E7A5  58			        pop     ax
 E7A6  BA 03C0			        mov     dx, 3c0h
 E7A9  B0 10			        mov     al, 10h
 E7AB  EE			        out     dx, al
 E7AC  8A C4			        mov     al, ah      
 E7AE  EE			        out     dx, al          ; set video mode
 E7AF  B0 13				mov	al, 13h
 E7B1  EE				out 	dx, al
 E7B2  B0 00				mov	al, 0
 E7B4  EE				out	dx, al		; 0 pan

 E7B5  B8 1123			        mov     ax, 1123h
 E7B8  CD 10			        int     10h             ; set ROM 8x8 font for graphics mode
 E7BA  B4 01			        mov     ah, 1
 E7BC  B9 0607			        mov		cx, 607h	; scanlines 13 and 14
 E7BF  CD 10			        int     10h         ; show cursor
 E7C1  F6 06 0089 08		        test    byte ptr VgaFlags, 8  ; test default palette loading
 E7C6  75 0F			        jnz     short setmodeexit     ; no default palette
 E7C8  B8 1012			        mov     ax, 1012h
 E7CB  33 DB			        xor     bx, bx
 E7CD  B9 0100			        mov     cx, 100h    
 E7D0  BA F801 R		        mov     dx, offset default_pal
 E7D3  0E			        push    cs
 E7D4  07			        pop     es
 E7D5  CD 10			        int     10h             ; set default palette
 E7D7				setmodeexit:
 E7D7  07			        pop     es
 E7D8  61			        popa
 E7D9				nullproc:
 E7D9  C3			        ret        

				; --------------- fn 01h, set cursor shape and visibility
 E7DA				cursor:     ; CH = start line (0-7), CH bit 5 = 1  -> cursor off
							; CL = end line (0-7)
 E7DA  50			        push    ax
 E7DB  52			        push    dx
 E7DC  89 0E 0060				mov		[CursorShape], cx
 E7E0  03 C9					add		cx, cx
 E7E2  FE C5					inc		ch
 E7E4  BA 03D4			        mov     dx, 3d4h
 E7E7  B0 0A			        mov     al, 0ah
 E7E9  8A E5					mov		ah, ch
 E7EB  EF			        out     dx, ax
 E7EC  40					inc		ax
 E7ED  8A E1			        mov     ah, cl
 E7EF  EF			        out     dx, ax
 E7F0  5A			        pop     dx
 E7F1  58			        pop     ax
 E7F2  C3			        ret

				;---------------- fn 02h, set cursor pos
 E7F3				curpos:
 E7F3  50			        push    ax
 E7F4  53			        push    bx
 E7F5  8A C7			        mov     al, bh
 E7F7  C1 EB 07			        shr     bx, 7
 E7FA  83 E3 0E			        and     bx, 0eh
 E7FD  89 57 50			        mov     CursorPos[bx], dx
 E800  80 3E 0049 03		        cmp     byte ptr ActiveVideoMode, 3
 E805  75 1E			        jne     short curpos1
 E807  3A 06 0062		        cmp     al, ActivePage
 E80B  75 18			        jne     short curpos1
 E80D  52			        push    dx
 E80E  33 C0			        xor     ax, ax
 E810  86 C6			        xchg    al, dh        
 E812  6B C0 50			        imul    ax, 80
 E815  03 C2			        add     ax, dx
 E817  BA 03D4			        mov     dx, 3d4h
 E81A  50			        push    ax
 E81B  8A E0				mov 	ah, al
 E81D  B0 0F				mov	al, 0fh
 E81F  EF				out	dx, ax
 E820  58				pop	ax
 E821  B0 0E				mov	al, 0eh
 E823  EF				out 	dx, ax
 E824  5A			        pop     dx
 E825				curpos1:        
 E825  5B			        pop     bx
 E826  58			        pop     ax
 E827  C3			        ret

				;---------------- fn 03h, get cursor pos
 E828				getcurpos:
 E828  53			        push    bx
 E829  C1 EB 07			        shr     bx, 7
 E82C  83 E3 0E			        and     bx, 0eh
 E82F  8B 57 50			        mov     dx, CursorPos[bx]
 E832  8B 0E 0060		        mov     cx, CursorShape
 E836  5B			        pop     bx
 E837  C3			        ret

				;---------------- fn 04h, light pen
 E838				lightpen:
 E838  B4 00			        mov     ah, 0   ; not triggered
 E83A  C3			        ret

				;---------------- fn 05h, set active video page
 E83B				apage:
 E83B  60			        pusha
 E83C  E8 0D0D			        call    flush
 E83F  24 07			        and     al, 7
 E841  8A F8			        mov     bh, al
 E843  A2 0062			        mov     ActivePage, al
 E846  A0 0049			        mov     al, ActiveVideoMode
 E849  3C 13			        cmp     al, 13h
 E84B  73 19				jae	short apage1
 E84D  3C 03			        cmp     al, 3
 E84F  77 25				ja	short apage2
 E851  B8 000A			        mov     ax, 0ah
 E854  E7 8A			        out     8ah, ax
 E856  40			        inc     ax
 E857  E7 8B			        out     8bh, ax
 E859  B4 03			        mov     ah, 3
 E85B  CD 10			        int     10h        ; get cursor pos
 E85D  B4 02			        mov     ah, 2
 E85F  CD 10			        int     10h        ; set cursor pos
 E861  B8 0400				mov	ax, 400h
 E864  EB 13			        jmp     short apage4
 E866				apage1:	
 E866  B8 000A			        mov     ax, 0ah		; mode 13h and 25h
 E869  02 C7			        add     al, bh
 E86B  E7 8A			        out     8ah, ax
 E86D  40			        inc     ax
 E86E  3C 12			        cmp     al, 12h
 E870  75 02			        jne     short apage3
 E872  B0 0A			        mov     al, 0ah
 E874				apage3: 
 E874  E7 8B				out     8bh, ax

 E876				apage2:
 E876  A1 004C				mov	ax, RegenLength
 E879				apage4:
 E879  C1 EB 08			        shr     bx, 8      ; page number
 E87C  F7 E3			        mul     bx
 E87E  8B D8			        mov     bx, ax     ; 1 means 4 bytes, or 2 characters
 E880  C1 E0 02			        shl     ax, 2	   ; 1 means 1 byte   
 E883  A3 004E			        mov     PageOffset, ax
 E886  BA 03D4			        mov     dx, 3d4h
 E889  8A E3				mov	ah, bl
 E88B  B0 0D				mov	al, 0dh
 E88D  EF				out	dx, ax
 E88E  8A E7				mov	ah, bh
 E890  48				dec	ax
 E891  EF				out	dx, ax
 E892  61			        popa
 E893  C3			        ret

				;---------------- fn 06h, scroll up / clr
 E894				scrollup:
 E894  60			        pusha
 E895  06			        push    es
 E896  87 CA			        xchg    cx, dx
 E898  2B CA			        sub     cx, dx
 E89A  41			        inc     cx
 E89B  E8 0047			        call    scr_params
 E89E				scrollup6:        
 E89E  68 B800			        push    0b800h          ; segment
 E8A1  07			        pop     es
 E8A2  02 D2			        add     dl, dl
 E8A4  03 FF			        add     di, di
 E8A6  03 3E 004E		        add     di, PageOffset  ; di = top left corner address
 E8AA  91			        xchg    ax, cx          ; ah = 0
 E8AB  84 DB			        test    bl, bl
 E8AD  74 13			        jz      short scrollup3       ; clear
 E8AF  2A E3			        sub     ah, bl
 E8B1  72 0F			        jb      short scrollup3       ; clear
 E8B3  03 F7			        add     si, di
 E8B5				scrollup4:        
 E8B5  8A C8			        mov     cl, al
 E8B7  F3/ 26: A5		        rep     movsw es:[si], es:[di]
 E8BA  03 F2			        add     si, dx
 E8BC  03 FA			        add     di, dx
 E8BE  FE CC			        dec     ah              
 E8C0  79 F3			        jns     short scrollup4       ; ch = lines - 1
 E8C2				scrollup3:                      
 E8C2  02 E3			        add     ah, bl          ; clear rectangle: DI=address, ah=lines, al=columns, bh=attribute
 E8C4  93			        xchg    ax, bx
 E8C5  B0 20			        mov     al, ' '
 E8C7				scrollup5:
 E8C7  8A CB			        mov     cl, bl
 E8C9  F3/ AB			        rep     stosw
 E8CB  03 FA			        add     di, dx
 E8CD  FE CF			        dec     bh
 E8CF  79 F6			        jns     short scrollup5       ; ch = lines - 1
 E8D1				scrollexit:
 E8D1  07			        pop     es
 E8D2  61			        popa
 E8D3  C3			        ret

				;---------------- fn 07h, scroll dn / clr
 E8D4				scrolldn:
 E8D4  FD			        std
 E8D5  60			        pusha
 E8D6  06			        push    es
 E8D7  F7 D9			        neg     cx
 E8D9  03 CA			        add     cx, dx
 E8DB  41			        inc     cx
 E8DC  E8 0006			        call    scr_params
 E8DF  F7 DA			        neg     dx
 E8E1  F7 DE			        neg     si
 E8E3  EB B9			        jmp     short scrollup6

 E8E5				scr_params:
 E8E5  8A D8			        mov     bl, al          ; lines
 E8E7  33 C0			        xor     ax, ax
 E8E9  86 C6			        xchg    al, dh
 E8EB  6B F8 50			        imul    di, ax, 80
 E8EE  03 FA			        add     di, dx
 E8F0  B2 50			        mov     dl, 80          ; dh = 0
 E8F2  2A D1			        sub     dl, cl
 E8F4  8A C3			        mov     al, bl
 E8F6  69 F0 00A0		        imul    si, ax, 160
 E8FA  C3			        ret
				;---------------- fn 08h, read char/attr
 E8FB				readchar:
 E8FB  53			        push    bx
 E8FC  E8 0004			        call    mode3chaddr
 E8FF  8B 07			        mov     ax, [bx]
 E901  5B			        pop     bx
 E902  C3			        ret

 E903				mode3chaddr:    ; returns current char address in mode3 in ds:bx. Input: bh=page, ds=40h 
 E903  50			        push    ax
 E904  81 E3 0700		        and     bx, 700h
 E908  8D 87 B800		        lea     ax, [bx+0b800h]
 E90C  C1 EB 07			        shr     bx, 7
 E90F  8B 5F 50			        mov     bx, CursorPos[bx]
 E912  8E D8			        mov     ds, ax
 E914  33 C0			        xor     ax, ax
 E916  86 C7			        xchg    al, bh
 E918  6B C0 50			        imul    ax, 80
 E91B  03 D8			        add     bx, ax
 E91D  03 DB			        add     bx, bx
 E91F  58			        pop     ax
 E920  C3			        ret

				;---------------- fn 09h, write char/attr
 E921				writecharattr:
 E921  50			        push    ax
 E922  06			        push    es
 E923  53			        push    bx
 E924  51			        push    cx
 E925  8A E3			        mov     ah, bl
 E927  E8 FFD9			        call    mode3chaddr
 E92A  1E			        push    ds
 E92B  07			        pop     es
 E92C  87 FB			        xchg    di, bx
 E92E  F3/ AB			        rep     stosw
 E930  87 FB			        xchg    di, bx
 E932  59			        pop     cx
 E933  5B			        pop     bx
 E934  07			        pop     es
 E935  58			        pop     ax
 E936  C3			        ret

				;---------------- fn 0ah, write char
 E937				writechar:
 E937  E3 0E			        jcxz    short writecharskip
 E939  53			        push    bx
 E93A  51			        push    cx
 E93B  E8 FFC5			        call    mode3chaddr
 E93E				writechar3:        
 E93E  88 07			        mov     [bx], al
 E940  83 C3 02			        add     bx, 2
 E943  E2 F9			        loop    short writechar3
 E945  59			        pop     cx
 E946  5B			        pop     bx
 E947				writecharskip:        
 E947  C3			        ret

				;---------------- fn 0eh, write char as TTY
 E948				writecharTTY:
 E948  50			        push    ax
 E949  53			        push    bx
 E94A  52			        push    dx
 E94B  8A 1E 0062		        mov     bl, ActivePage
 E94F  B7 00			        mov     bh, 0
 E951  03 DB			        add     bx, bx
 E953  8B 57 50			        mov     dx, CursorPos[bx]
 E956  C1 E3 07			        shl     bx, 7
 E959  B4 0A			        mov     ah, 0ah
 E95B  E8 0008			        call    tty
 E95E  B4 02			        mov     ah, 2       ; set cursor pos
 E960  CD 10			        int     10h
 E962  5A			        pop     dx
 E963  5B			        pop     bx
 E964  58			        pop     ax 
 E965  C3			        ret        

 E966				tty:    ; dx=xy, bh=page, al=char, bl=attr, ah=0ah(no attr) or 09h(with attr)
 E966  F7 06 0018 0008		        test    word ptr KbdFlags2, Pause
 E96C  75 F8			        jnz     short tty
 E96E  51			        push    cx
 E96F  3C 07			        cmp     al, 7
 E971  74 1A			        je      short bell
 E973  3C 08			        cmp     al, 8
 E975  74 18			        je      short bs
 E977  3C 0A			        cmp     al, 0ah
 E979  74 22			        je      short cr
 E97B  3C 0D			        cmp     al, 0dh
 E97D  74 18			        je      short lf
 E97F  B9 0001			        mov     cx, 1
 E982  CD 10			        int     10h         ; write char at cursor
 E984  42			        inc     dx
 E985  3A 16 004A		        cmp     dl, ScreenWidth
 E989  73 10			        jae     short crlf
 E98B				tty1:
 E98B  59			        pop     cx
 E98C  C3			        ret
 E98D				bell:
				; TODO bell code        
 E98D  EB FC			        jmp     short tty1
 E98F				bs:
 E98F  80 EA 01			        sub     dl, 1
 E992  80 D2 00			        adc     dl, 0      
 E995  EB F4			        jmp     short tty1
 E997				lf:
 E997  B2 00			        mov     dl, 0
 E999  EB F0			        jmp     short tty1
 E99B				crlf:
 E99B  B2 00			        mov     dl, 0        
 E99D				cr:        
 E99D  FE C6			        inc     dh
 E99F  3A 36 0084		        cmp     dh, ScreenRows
 E9A3  76 E6			        jbe     short tty1
 E9A5  FE CE			        dec     dh
				;        mov     ah, 8
				;        int     10h         ; read attribute at cursor pos
 E9A7  53			        push    bx          ; save active page in bh
 E9A8  52			        push    dx
				;        xchg    ax, bx
 E9A9  B7 07			        mov     bh, 7       ; default attribute
 E9AB  B8 0601			        mov     ax, 601h    
 E9AE  8A 36 0084		        mov     dh, ScreenRows
 E9B2  8A 16 004A		        mov     dl, ScreenWidth
 E9B6  4A			        dec     dx
 E9B7  33 C9			        xor     cx, cx
 E9B9  CD 10			        int     10h         ; scroll up
 E9BB  5A			        pop     dx
 E9BC  5B			        pop     bx          ; restore active page in bh         
 E9BD  EB CC			        jmp     short tty1
				        
				;---------------- fn 0fh, read video mode
 E9BF				readmode:
 E9BF  A0 0087			        mov     al, EgaMiscInfo
 E9C2  24 80			        and     al, 80h
 E9C4  0A 06 0049		        or      al, ActiveVideoMode
 E9C8  8A 26 004A		        mov     ah, ScreenWidth
 E9CC  8A 3E 0062		        mov     bh, ActivePage
 E9D0  C3			        ret


				;---------------- fn 10h, palette
 E9D1 EA64 R EA24 R EA7F R	paltable    dw  setonereg, palexit, setallreg, setblink, palexit, palexit, palexit, readonereg, readoverscan, readallreg, palexit, palexit, palexit, palexit, palexit, palexit
       EA93 R EA24 R EA24 R
       EA24 R EAB8 R EB02 R
       EAEB R EA24 R EA24 R
       EA24 R EA24 R EA24 R
       EA24 R
 E9F1  EB05 R EA24 R EB1B R	            dw  setoneDAC, palexit, setblockDAC, paging, palexit, readoneDAC, palexit, readblockDAC, setPELmask, getPELmask, getpaging, grayscale
       EB2C R EA24 R EB47 R
       EA24 R EB5F R EB70 R
       EB79 R EB82 R EB8D R

 EA09				pal:
 EA09  3C 1B			        cmp     al, 1bh
 EA0B  77 17			        ja      short palexit
 EA0D  8B F0			        mov     si, ax
 EA0F  03 F6			        add     si, si
 EA11  00 26 006A		        add     byte ptr PalPagingCounter, ah   ; prevents <palpage> re-entrance on recursive <pal> calls
 EA15  E8 000D			        call    palpage     
 EA18  2E: FF 94 C9D1 R		        call    cs:paltable[si-2000h]
 EA1D  E8 0005			        call    palpage
 EA20  28 26 006A		        sub     byte ptr PalPagingCounter, ah
 EA24				palexit:
 EA24  C3			        ret

 EA25				palpage:                    ; executes only if PalPagingCounter == ah
 EA25  38 26 006A		        cmp     byte ptr PalPagingCounter, ah   
 EA29  75 38			        jne     short palpageexit
 EA2B				palpageset:        
 EA2B  F6 06 0069 0F		        test    byte ptr PalPaging, 0fh
 EA30  74 31			        jz      short palpageexit
 EA32  60			        pusha
 EA33  8A 1E 0069		        mov     bl, byte ptr PalPaging
 EA37  02 DB			        add     bl, bl
 EA39  72 03			        jc      short page16
 EA3B  C0 E3 02			        shl     bl, 2
 EA3E				page16:
 EA3E  C1 E3 0B			        shl     bx, 11  ; bh=target page, bl=0 page
 EA41				palpage1:
 EA41  B0 15			        mov     al, 15h
 EA43  CD 10			        int     10h     ; read 0 page DAC reg
 EA45  51			        push    cx
 EA46  52			        push    dx
 EA47  86 DF			        xchg    bl, bh
 EA49  CD 10			        int     10h     ; read target page DAC register
 EA4B  86 DF			        xchg    bl, bh
 EA4D  B0 10			        mov     al, 10h
 EA4F  CD 10			        int     10h     ; write 0 page DAC register
 EA51  5A			        pop     dx
 EA52  59			        pop     cx
 EA53  86 DF			        xchg    bl, bh
 EA55  CD 10			        int     10h     ; write target page DAC register
 EA57  86 DF			        xchg    bl, bh
 EA59  81 C3 0101		        add     bx, 101h; next DAC reg
 EA5D  F6 C3 0F			        test    bl, 0fh
 EA60  75 DF			        jnz     short palpage1                    
 EA62  61			        popa
 EA63				palpageexit:        
 EA63  C3			        ret

 EA64				setonereg:
 EA64  80 FB 10			        cmp     bl, 10h
 EA67  73 15			        jae     setonereg1
 EA69  60			        pusha
 EA6A  E8 014E			        call    colfrombits
 EA6D  8A C8			        mov     cl, al
 EA6F  E8 0149			        call    colfrombits
 EA72  8A E8			        mov     ch, al
 EA74  E8 0144			        call    colfrombits
 EA77  8A F0			        mov     dh, al
 EA79  B0 10			        mov     al, 10h
 EA7B  CD 10			        int     10h
 EA7D  61			        popa
 EA7E				setonereg1:        
 EA7E  C3			        ret        

 EA7F				setallreg:
 EA7F  60			        pusha
 EA80  B0 00			        mov     al, 0
 EA82  8B F2			        mov     si, dx
 EA84  B3 0F			        mov     bl, 15
 EA86				setallreg1:        
 EA86  26: 8A 7C 0F		        mov     bh, es:[si+15]
 EA8A  CD 10			        int     10h
 EA8C  4E			        dec     si
 EA8D  FE CB			        dec     bl
 EA8F  79 F5			        jns     short setallreg1
 EA91  61			        popa
 EA92  C3			        ret

 EA93				setblink:
 EA93  60			        pusha
 EA94  80 3E 0049 03		        cmp     byte ptr ActiveVideoMode, 3
 EA99  75 1B			        jne     short setblink1
 EA9B  BA 03C0			        mov     dx, 3c0h
 EA9E  B0 10			        mov     al, 10h
 EAA0  EE			        out     dx, al
 EAA1  8A C3			        mov     al, bl
 EAA3  24 01			        and     al, 1
 EAA5  C0 E0 03			        shl     al, 3      
 EAA8  EE			        out     dx, al          ; set video mode (0 or 8)
 EAA9  C0 E0 02			        shl     al, 2
 EAAC  32 06 0089		        xor     al, VgaFlags
 EAB0  24 20			        and     al, 20h
 EAB2  30 06 0089		        xor     VgaFlags, al
 EAB6				setblink1:
 EAB6  61			        popa
 EAB7  C3			        ret

 EAB8				readonereg:
 EAB8  80 FB 10			        cmp     bl, 10h
 EABB  73 2D			        jae     readonereg1
 EABD  50			        push    ax
 EABE  51			        push    cx
 EABF  52			        push    dx
 EAC0  B0 15			        mov     al, 15h
 EAC2  CD 10			        int     10h
 EAC4  8A C6			        mov     al, dh          ; al = R
 EAC6  24 30			        and     al, 00110000b
 EAC8  C0 E8 02			        shr     al, 2
 EACB  04 78			        add     al, 01111000b
 EACD  24 84			        and     al, 10000100b
 EACF  8A F8			        mov     bh, al
 EAD1  91			        xchg    ax, cx          ; ax = GB
 EAD2  25 3030			        and     ax, 0011000000110000b
 EAD5  C1 E8 03			        shr     ax, 3
 EAD8  D0 E8			        shr     al, 1
 EADA  05 3C1E			        add     ax, 0011110000011110b
 EADD  25 4221			        and     ax, 0100001000100001b
 EAE0  0A FC			        or      bh, ah
 EAE2  0A F8			        or      bh, al
 EAE4  C0 C7 03			        rol     bh, 3
 EAE7  5A			        pop     dx
 EAE8  59			        pop     cx
 EAE9  58			        pop     ax
 EAEA				readonereg1:        
 EAEA  C3			        ret

 EAEB				readallreg:
 EAEB  60			        pusha
 EAEC  8B FA			        mov     di, dx
 EAEE  B3 00			        mov     bl, 0
 EAF0				readllreg1:
 EAF0  B0 07			        mov     al, 7
 EAF2  CD 10			        int     10h
 EAF4  8A C7			        mov     al, bh
 EAF6  AA			        stosb
 EAF7  43			        inc     bx
 EAF8  80 FB 10			        cmp     bl, 16
 EAFB  75 F3			        jne     short readllreg1
 EAFD  B0 00			        mov     al, 0   ; overscan color
 EAFF  AA			        stosb
 EB00  61			        popa
 EB01  C3			        ret

 EB02				readoverscan:
 EB02  B7 00			        mov     bh, 0
 EB04  C3			        ret

 EB05				setoneDAC:
 EB05  50			        push    ax
 EB06  52			        push    dx
 EB07  92			        xchg    ax, dx
 EB08  8A C3			        mov     al, bl
 EB0A  BA 03C8			        mov     dx, 3c8h
 EB0D  EE			        out     dx, al
 EB0E  42			        inc     dx
 EB0F  8A C4			        mov     al, ah
 EB11  EE			        out     dx, al
 EB12  8A C5			        mov     al, ch
 EB14  EE			        out     dx, al
 EB15  8A C1			        mov     al, cl
 EB17  EE			        out     dx, al
 EB18  5A			        pop     dx
 EB19  58			        pop     ax
 EB1A  C3			        ret

 EB1B				setblockDAC:
 EB1B  60			        pusha
 EB1C  8B F2			        mov     si, dx
 EB1E  BA 03C8			        mov     dx, 3c8h
 EB21  93			        xchg    ax, bx
 EB22  EE			        out     dx, al
 EB23  42			        inc     dx
 EB24  6B C9 03			        imul    cx, 3
 EB27  F3/ 26: 6E		        rep     outsb dx, es:[si]
 EB2A  61			        popa
 EB2B  C3			        ret

 EB2C				paging:
 EB2C  53			        push    bx
 EB2D  84 DB			        test    bl, bl
 EB2F  8A 1E 0069		        mov     bl, PalPaging
 EB33  75 06			        jnz     short paging1
 EB35  02 DB			        add     bl, bl
 EB37  D1 CB			        ror     bx, 1
 EB39  EB 06			        jmp     short paging2
 EB3B				paging1:
 EB3B  81 E3 0F80		        and     bx, 0f80h       ; bl=old page, bh=new page
 EB3F  0A DF			        or      bl, bh 
 EB41				paging2:        
 EB41  88 1E 0069		        mov     PalPaging, bl
 EB45  5B			        pop     bx
 EB46  C3			        ret

 EB47				readoneDAC:
 EB47  50			        push    ax
 EB48  52			        push    dx
 EB49  8A C3			        mov     al, bl
 EB4B  BA 03C7			        mov     dx, 3c7h
 EB4E  EE			        out     dx, al
 EB4F  42			        inc     dx
 EB50  42			        inc     dx
 EB51  EC			        in      al, dx
 EB52  8A E0			        mov     ah, al
 EB54  EC			        in      al, dx
 EB55  8A E8			        mov     ch, al
 EB57  EC			        in      al, dx
 EB58  8A C8			        mov     cl, al
 EB5A  5A			        pop     dx
 EB5B  8A F4			        mov     dh, ah
 EB5D  58			        pop     ax             
 EB5E  C3			        ret

 EB5F				readblockDAC:
 EB5F  60			        pusha
 EB60  8B FA			        mov     di, dx
 EB62  BA 03C7			        mov     dx, 3c7h
 EB65  93			        xchg    ax, bx
 EB66  EE			        out     dx, al
 EB67  42			        inc     dx
 EB68  42			        inc     dx
 EB69  6B C9 03			        imul    cx, 3
 EB6C  F3/ 6C			        rep     insb                
 EB6E  61			        popa
 EB6F  C3			        ret

 EB70				setPELmask:
 EB70  52			        push    dx
 EB71  93			        xchg    ax, bx
 EB72  BA 03C6			        mov     dx, 3c6h
 EB75  EE			        out     dx, al
 EB76  93			        xchg    ax, bx
 EB77  5A			        pop     dx
 EB78  C3			        ret

 EB79				getPELmask:
 EB79  52			        push    dx
 EB7A  93			        xchg    ax, bx
 EB7B  BA 03C6			        mov     dx, 3c6h
 EB7E  EC			        in      al, dx
 EB7F  93			        xchg    ax, bx
 EB80  5A			        pop     dx
 EB81  C3			        ret

 EB82				getpaging:
 EB82  8A 3E 0069		        mov     bh, PalPaging
 EB86  B3 00			        mov     bl, 0
 EB88  D1 C3			        rol     bx, 1
 EB8A  D0 EF			        shr     bh, 1        
 EB8C  C3			        ret

 EB8D				grayscale:
 EB8D  E3 2B			        jcxz    short grayscale2
 EB8F  60			        pusha
 EB90  8A F9			        mov     bh, cl
 EB92				grayscale1:        
 EB92  B0 15			        mov     al, 15h
 EB94  CD 10			        int     10h
 EB96  C1 EA 08			        shr     dx, 8
 EB99  6B F2 4D			        imul    si, dx, 77
 EB9C  8A D5			        mov     dl, ch
 EB9E  69 D2 0097		        imul    dx, 151
 EBA2  B5 00			        mov     ch, 0
 EBA4  6B C9 1C			        imul    cx, 28
 EBA7  03 D6			        add     dx, si
 EBA9  03 D1			        add     dx, cx
 EBAB  8A EE			        mov     ch, dh
 EBAD  8A CE			        mov     cl, dh
 EBAF  B0 10			        mov     al, 10h
 EBB1  CD 10			        int     10h
 EBB3  FE C3			        inc     bl
 EBB5  FE CF			        dec     bh
 EBB7  75 D9			        jne     short grayscale1        
 EBB9  61			        popa
 EBBA				grayscale2:        
 EBBA  C3			        ret

 EBBB				colfrombits:    ; input: bh, output: al
 EBBB  D0 EF			        shr     bh, 1
 EBBD  1A C0			        sbb     al, al
 EBBF  24 2A			        and     al, 2ah
 EBC1  F6 C7 04			        test    bh, 4
 EBC4  74 02			        jz      short col1
 EBC6  0C 15			        or      al, 15h
 EBC8				col1:
 EBC8  C3			        ret                


				;---------------- fn 11h, character generator
 EBC9				loadUDF:
 EBC9  81 FB 1000		        cmp     bx, 1000h
 EBCD  75 0F			        jne     loadUDFexit     ; only 16bytes chars and font block 0 supported
 EBCF  60			        pusha
 EBD0  92			        xchg    ax, dx
 EBD1  BA 03CB			        mov     dx, 03cbh
 EBD4  EF			        out     dx, ax
 EBD5  8B F5			        mov     si, bp
 EBD7  C1 E1 04			        shl     cx, 4
 EBDA  F3/ 26: 6E		        rep     outsb dx, es:[si]        
 EBDD  61			        popa
 EBDE				loadUDFexit:        
 EBDE  C3			        ret

 EBDF				chargen:
 EBDF  A8 EF			        test    al, not 10h     ; test for 00h and 10h
 EBE1  74 E6			        jz      short loadUDF
 EBE3  A8 EE			        test    al, not 11h     ; test for 01h and 11h
 EBE5  74 1B			        jz      short loadROMfont
 EBE7  A8 ED			        test    al, not 12h     ; test for 02h and 12h
 EBE9  74 17			        jz      short loadROMfont
 EBEB  A8 EB			        test    al, not 14h     ; test for 04h and 14h
 EBED  74 13			        jz      short loadROMfont
 EBEF  3C 20			        cmp     al, 20h
 EBF1  72 EB			        jb      loadUDFexit
 EBF3  74 21			        je      short set1f
 EBF5  3C 21			        cmp     al, 21h
 EBF7  74 28			        je      short setgrUDF
 EBF9  3C 24			        cmp     al, 24h
 EBFB  76 51			        jbe     short setROMgrFont
 EBFD  3C 30			        cmp     al, 30h
 EBFF  74 6B			        je      short getfontinfo
 EC01  C3			        ret

 EC02				loadROMFont:
 EC02  06			        push    es
 EC03  60			        pusha
 EC04  BB 1000			        mov     bx, 1000h       ; 8x16 chars, block 0
 EC07  B9 0100			        mov     cx, 100h        ; all chars
 EC0A  33 D2			        xor     dx, dx
 EC0C  BD E056 R		        mov     bp, offset font8x16
 EC0F  0E			        push    cs
 EC10  07			        pop     es
 EC11  B0 00			        mov     al, 0           
				;        int     10h             ; loadUDF
 EC13  61			        popa
 EC14  07			        pop     es
 EC15  C3			        ret

 EC16				set1f:
 EC16  33 F6			        xor     si, si
 EC18  8E DE			        mov     ds, si
 EC1A  89 6C 7C			        mov     [si+1fh*4], bp
 EC1D  8C 44 7E			        mov     [si+1fh*4+2], es
 EC20  C3			        ret
				        
 EC21				setgrUDF:
 EC21  60			        pusha
 EC22  E3 BA			        jcxz    short loadUDFexit
 EC24  1E			        push    ds
 EC25  33 F6			        xor     si, si
 EC27  8E DE			        mov     ds, si
 EC29  89 AC 010C		        mov     [si+43h*4], bp
 EC2D  8C 84 010E		        mov     [si+43h*4+2], es
 EC31  1F			        pop     ds
 EC32  B8 00C8			        mov     ax, 200
 EC35  80 3E 0049 13		        cmp     byte ptr ActiveVideoMode, 13h
 EC3A  72 10			        jb      short setgrUDFexit
 EC3C  74 03			        je      short setgrUDF1
 EC3E  B8 01E0			        mov     ax, 480         ; mode 25h, 480 lines
 EC41				setgrUDF1:
 EC41  89 0E 0085		        mov     ScanLinesChar, cx
 EC45  99			        cwd
 EC46  F7 F1			        div     cx
 EC48  48			        dec     ax
 EC49  A2 0084			        mov     ScreenRows, al
 EC4C				setgrUDFexit:
 EC4C  61			        popa
 EC4D  C3			        ret

 EC4E				setROMgrFont:       
 EC4E  60			        pusha
 EC4F  06			        push    es
 EC50  B9 0008			        mov     cx, 8
 EC53  0E			        push    cs
 EC54  07			        pop     es
 EC55  BD E056 R		        mov     bp, offset font8x8
 EC58  3C 23			        cmp     al, 23h
 EC5A  74 03			        je      short setROMgrFont1
 EC5C  BD E056 R		        mov     bp, offset font8x16
 EC5F				setROMgrFont1:        
 EC5F  B0 21			        mov     al, 21h
 EC61  CD 10			        int     10h     ; set graphic UDF
 EC63  48			        dec     ax
 EC64  BD E456 R		        mov     bp, offset font8x8 + 128*8
 EC67  CD 10			        int     10h     ; set INT 1fh
 EC69  07			        pop     es
 EC6A  61			        popa
 EC6B  C3			        ret
				        
 EC6C				getfontinfo:
 EC6C  8B 0E 0085		        mov     cx, ScanLinesChar
 EC70  8A 16 0084		        mov     dl, ScreenRows
 EC74  80 FF 01			        cmp     bh, 1
 EC77  77 0E			        ja      short getfontinfo1
 EC79  6A 00			        push    0
 EC7B  1F			        pop     ds
 EC7C  C4 2E 007C		        les     bp, ds:[1fh*4] 
 EC80  72 18			        jb      short getfontinfoexit
 EC82  C4 2E 010C		        les     bp, ds:[43h*4]
 EC86  C3			        ret
 EC87				getfontinfo1:
 EC87  80 FF 07			        cmp     bh, 7
 EC8A  77 0E			        ja      short getfontinfoexit
 EC8C  8B F3			        mov     si, bx
 EC8E  C1 EE 08			        shr     si, 8
 EC91  03 F6			        add     si, si
 EC93  2E: 8B AC EC97 R		        mov     bp, cs:fontinfo[si-4]
 EC98  0E			        push    cs
 EC99  07			        pop     es                    
 EC9A				getfontinfoexit:
 EC9A  C3			        ret

 EC9B E056 R E056 R E456 R	fontinfo    dw  font8x16, font8x8, font8x8+128*8, font8x16, font8x16, font8x16
       E056 R E056 R E056 R

				;---------------- fn 12h, special functions
 ECA7				special:
 ECA7  80 FB 10			        cmp     bl, 10h
 ECAA  75 0B			        jne     short special1
 ECAC  8A 0E 0088		        mov     cl, EgaMiscInfo2    ; cl = switch settings
 ECB0  83 E1 0F			        and     cx, 15              ; ch <- 0 (feature bits)
 ECB3  BB 0003			        mov     bx, 3               ; bh <- 0 (color mode), bl = video memory size
 ECB6  C3			        ret
 ECB7				special1:
 ECB7  80 FB 31			        cmp     bl, 31h
 ECBA  75 0F			        jne     short special2
 ECBC  F6 D8			        neg     al
 ECBE  32 06 0089		        xor     al, VgaFlags
 ECC2  24 08			        and     al, 8       ; transfer palette loading bit to VgaFlags
 ECC4  30 06 0089		        xor     VgaFlags, al
 ECC8  B0 12			        mov     al, 12h     ; supported function
 ECCA  C3			        ret
 ECCB				special2:
 ECCB  B0 00			        mov     al, 0       ; unsupported function
 ECCD  C3			        ret


				;---------------- fn 13h, write string
 ECCE				writestr:
 ECCE  E3 31			        jcxz    short wstrexit
 ECD0  60			        pusha
 ECD1  8B F3			        mov     si, bx
 ECD3  C1 EE 08			        shr     si, 8
 ECD6  03 F6			        add     si, si
 ECD8  FF 74 50			        push    CursorPos[si]
 ECDB  B4 09			        mov     ah, 9       ; write tty char/attribute
 ECDD				wstr1:        
 ECDD  50			        push    ax
 ECDE  A8 02			        test    al, 2
 ECE0  26: 8A 46 00		        mov     al, es:[bp]
 ECE4  74 05			        jz      short noattr
 ECE6  45			        inc     bp
 ECE7  26: 8A 5E 00		        mov     bl, es:[bp]
 ECEB				noattr:
 ECEB  45			        inc     bp
 ECEC  89 54 50			        mov     CursorPos[si], dx
 ECEF  E8 FC74			        call    tty
 ECF2  58			        pop     ax
 ECF3  E2 E8			        loop    short wstr1
 ECF5  8F 44 50			        pop     CursorPos[si]
 ECF8  A8 01			        test    al, 1
 ECFA  74 04			        jz      short wstr2             
 ECFC  B4 02			        mov     ah, 2       ; set cursor pos
 ECFE  CD 10			        int     10h                
 ED00				wstr2:        
 ED00  61			        popa
 ED01				wstrexit:        
 ED01  C3			        ret

				;---------------- fn 1ah, get/set display combination code
 ED02				getdcc:
 ED02  3C 01			        cmp     al, 1
 ED04  77 0C			        ja      short getdccexit
 ED06  8A C4			        mov     al, ah
 ED08  74 03			        je      short setdcc
 ED0A  BB 0008			        mov     bx, 08h
 ED0D				dccval  label word        
 ED0D				setdcc:
 ED0D  2E: 89 1E ED0B R		        mov     cs:[dccval-2], bx
 ED12				getdccexit:        
 ED12  C3			        ret        

				;---------------- fn 1bh, query status
 ED13				querystatus:
 ED13  60			        pusha
 ED14  B8 ED72 R		        mov     ax, offset staticfunctable
 ED17  AB			        stosw
 ED18  8C C8			        mov     ax, cs
 ED1A  AB			        stosw
 ED1B  BE 0049			        mov     si, offset ActiveVideoMode
 ED1E  80 3C 12			        cmp     byte ptr [si], 12h
 ED21  B9 0021			        mov     cx, 33          ; info copied from BDA        
 ED24  F3/ A4			        rep     movsb
 ED26  B8 0008			        mov     ax, 8
 ED29  AB			        stosw                   ; display info (one VGA analog color monitor)
 ED2A  BB 0208			        mov     bx, 208h        ; 400 scan lines, 8 pages
 ED2D  B0 10			        mov     al, 10h         ; 16 colors         
 ED2F  72 14			        jb      short querystatus1	; mode03h
 ED31  BB 0302				mov	bx, 302h	; 480 scan lines, 2 pageS
 ED34  74 0F			        je	short querystatus1	; mode12h 
 ED36  B7 00			        mov     bh, 0           ; scan lines code (0=200, 1=350, 2=400, 3=480)
 ED38  B8 0100			        mov     ax, 100h        ; 256 colors
 ED3B  80 3E 0049 13		        cmp     byte ptr ActiveVideoMode, 13h
 ED40  74 0D			        je      short querystatus3     ; mode13h
 ED42  BB 0301			        mov     bx, 301h        ; 480 scan lines, 1 page
 ED45				querystatus1:
 ED45  80 3E 0049 0D			cmp	byte ptr ActiveVideoMode, 0dh
 ED4A  75 03				jne	short querystatus3
 ED4C  BB 0008				mov	bx, 0008h	; 200 scan lines, 8 pages
 ED4F				querystatus3:
 ED4F  AB			        stosw
 ED50  93			        xchg    ax, bx
 ED51  AB			        stosw
 ED52  33 C0			        xor     ax, ax
 ED54  AB			        stosw                   ; font block info (45)
 ED55  A0 0089			        mov     al, VgaFlags
 ED58  24 2F			        and     al, 00101111b
 ED5A  AB			        stosw        
 ED5B  AB			        stosw
 ED5C  A0 0087			        mov     al, EgaMiscInfo
 ED5F  C0 E8 04			        shr     al, 4
 ED62  24 07			        and     al, 7           ; video memory size
 ED64  AB			        stosw
 ED65  B0 02			        mov     al, 2
 ED67  AA			        stosb                   ; color display attached
 ED68  B1 06			        mov     cl, 6
 ED6A  33 C0			        xor     ax, ax
 ED6C  F3/ AB			        rep     stosw           ; 12 reserved bytes
 ED6E  61			        popa
 ED6F  8A C4			        mov     al, ah          ; supported function
 ED71  C3			        ret

 ED72 0C			staticfunctable db  00001100b   ; video modes 2h, 3h supported
 ED73  20			                db  00100000b	; video mode 0dh supported
 ED74  0C			                db  00001100b   ; video modes 12h, 13h supported
 ED75  00			                db  00000000b
 ED76  20			                db  00100000b   ; video mode 25h supported
 ED77  00 00			                db  0, 0
 ED79  04			                db  00000100b   ; 400 scanline supported
 ED7A  01			                db  1           ; font blocks available in text mode
 ED7B  01			                db  1           ; max active font blocks available in text mode

				;Bit(s)  Description
				;0      all modes on all displays function supported
				;1      gray summing function supported
				;2      character font loading function supported
				;3      default palette loading enable/disable supported
				;4      cursor emulation function supported
				;5      EGA palette present
				;6      color palette present
				;7      color-register paging function supported
				;8      light pen supported (see AH=04h)
				;9      save/restore state function 1Ch supported
				;10     intensity/blinking function supported (see AX=1003h)
				;11     Display Combination Code supported (see #00039)
				;12-15  unused (0)
 ED7C  EF			                db  11101111b   ; miscellaneous function support flags 
 ED7D  0C			                db  00001100b   ; miscellaneous function support flags
				                 
 ED7E  00 00			                db  0, 0        ; reserved
 ED80  00			                db  0           ; save pointer function flags
 ED81  00			                db  0           ; reserved  

				       
 ED82 E687 R E7DA R E7F3 R	vidtbl  dw  setmode, cursor, curpos, getcurpos, lightpen, apage, scrollup, scrolldn, readchar, writecharattr
       E828 R E838 R E83B R
       E894 R E8D4 R E8FB R
       E921 R
 ED96  E937 R E7D9 R E7D9 R	        dw  writechar, nullproc, nullproc, nullproc, writecharTTY, readmode
       E7D9 R E948 R E9BF R
 EDA2  EA09 R EBDF R ECA7 R	        dw  pal, chargen, special, writestr, nullproc, nullproc, nullproc, nullproc, nullproc, nullproc, getdcc, querystatus, nullproc
       ECCE R E7D9 R E7D9 R
       E7D9 R E7D9 R E7D9 R
       E7D9 R ED02 R ED13 R
       E7D9 R
 EDBC				int10 endp

				; --------------------- INT 11h - Equipment ----------------
 = ds:[10h]			EquipmentWord       equ     <ds:[10h]>

 EDBC				int11   proc near
 EDBC  1E			        push    ds
 EDBD  6A 40			        push    40h
 EDBF  1F			        pop     ds
 EDC0  A1 0010			        mov     ax, EquipmentWord
 EDC3  1F			        pop     ds
 EDC4  CF			        iret
 EDC5				int11   endp

				; --------------------- INT 12h - Memory size ----------------
 = ds:[13h]			MemorySize       equ     <ds:[13h]>

 EDC5				int12   proc near
 EDC5  1E			        push    ds
 EDC6  6A 40			        push    40h
 EDC8  1F			        pop     ds
 EDC9  A1 0013			        mov     ax, MemorySize
 EDCC  1F			        pop     ds
 EDCD  CF			        iret        
 EDCE				int12   endp

				; --------------------- INT 13h - Disk services ----------------
 = ds:[74h]			HDLastError       equ     <ds:[74h]>
 = ds:[92h]			HDOpStarted       equ     <ds:[92h]>    ; bit 3: in INT13h (all other bits must be 0)
 = ds:[94h]			HDSize            equ     <ds:[94h]>

 EDCE				int13   proc near
 EDCE  1E			        push    ds
 EDCF  55			        push    bp
 EDD0  6A 40			        push    40h
 EDD2  1F			        pop     ds
 EDD3  80 36 0092 08		        xor     byte ptr HDOpStarted, 8
 EDD8  74 13			        jz      short inINT13
 EDDA  FB			        sti                     
 EDDB  FC			        cld
 EDDC  80 FC 1A			        cmp     ah, 1ah
 EDDF  76 10			        jbe     short Disk1
 EDE1  80 EC 26			        sub     ah, 41h-1bh     ; extensions
 EDE4  80 FC 22			        cmp     ah, 22h
 EDE7  76 08			        jbe     short Disk1
 EDE9  B4 01			        mov     ah, 1           ; bad command error
 EDEB  EB 14			        jmp     short exit
 EDED				inINT13:        
 EDED  B4 AA			        mov     ah, 0aah        ; drive not ready
 EDEF  EB 14			        jmp     short exit2
 EDF1				Disk1:
 EDF1  8B E8			        mov     bp, ax
 EDF3  C1 ED 07			        shr     bp, 7
 EDF6  81 E5 01FE		        and     bp, 1feh
 EDFA  1E			        push    ds
 EDFB  2E: FF 96 EE19 R		        call    cs:disktbl[bp]
 EE00  1F			        pop     ds
 EE01				exit:        
 EE01  88 26 0074		        mov     HDLastError, ah
 EE05				exit2:
 EE05  80 36 0092 08		        xor     byte ptr HDOpStarted, 8
 EE0A  F6 DC			        neg     ah              ; CF <- (AH != 0)
 EE0C				exit1:
 EE0C  8B EC			        mov     bp, sp
 EE0E  D0 5E 08			        rcr     byte ptr [bp+8], 1
 EE11  D0 46 08			        rol     byte ptr [bp+8], 1  ; insert error CF on stack
 EE14  F6 DC			        neg     ah
 EE16  5D			        pop     bp
 EE17  1F			        pop     ds
 EE18  CF			        iret

 EE19 EE8D R EE90 R EE9F R	disktbl dw      DiskReset, DiskGetStatus, DiskRead, DiskWrite, DiskVerify, DiskFormat, DiskFormat, DiskFormat, DiskGetParams, DiskInit, DiskRead, DiskWrite, DiskSeek, DiskRst, DiskReadSectBuffer, DiskWriteSectBuffer
       EE9A R EE95 R EEE9 R
       EEE9 R EEE9 R EEF8 R
       EEE9 R EE9F R EE9A R
       EEE9 R EEE9 R EFB8 R
       EFB8 R
 EE39  EEE9 R EEE9 R EEE9 R	        dw      DiskReady, DiskRecalibrate, DiskDiag, DiskDiag, DiskDiag, DiskGetType, DiskChanged, DiskSetDASDType, DiskSetMediaType, DiskPark, DiskFormat,  DiskExtInstCheck, DiskExtRead, DiskExtWrite, DiskExtVerify, DiskExtLock
       EEE9 R EEE9 R EE5F R
       EE8D R EFB8 R EFB8 R
       EE8D R EEE9 R EE7F R
       EF39 R EF34 R EF2F R
       EFB8 R
 EE59  EFB8 R EEE9 R EF6B R	        dw      DiskExtEject, DiskExtSeek, DiskExtGetParams

 EE5F				DiskGetType:
 EE5F  80 FA 80			        cmp     dl, 80h
 EE62  75 29			        jne     short DiskReset ; ah=0, drive not present
 EE64  8B 0E 0094		        mov     cx, HDSize      
 EE68  8B D1			        mov     dx, cx
 EE6A  85 C9			        test    cx, cx
 EE6C  74 1F			        jz      short DiskReset ; ah=0, drive not present
 EE6E  B4 FD			        mov     ah, -3      ; HD present
 EE70  C1 E9 06			        shr     cx, 6
 EE73  C1 E2 0A			        shl     dx, 10      ; CX:DX = HDSize * 1024
 EE76				DiskGetTypeexit:        
 EE76  1F			        pop     ds          ; discard ret address
 EE77  1F			        pop     ds          ; discard DS
 EE78  80 36 0092 08		        xor     byte ptr HDOpStarted, 8     ; CF <- 0 
 EE7D  EB 8D			        jmp     short   exit1        

 EE7F				DiskExtInstCheck:
 EE7F  86 DF			        xchg    bl, bh
 EE81  B4 FF			        mov     ah, -1
 EE83  B9 0001			        mov     cx, 1       ; extended disk access functions (AH=42h-44h,47h,48h) supported
 EE86  80 FA 80			        cmp     dl, 80h
 EE89  75 6A			        jne     short notready
 EE8B  EB E9			        jmp     short DiskGetTypeexit

 EE8D				DiskReset:
 EE8D				DiskChanged:
 EE8D				DiskPark:
 EE8D  B4 00			        mov     ah, 0       ; success
 EE8F  C3			        ret

 EE90				DiskGetStatus:
 EE90  8A 26 0074		        mov     ah, HDLastError
 EE94  C3			        ret
				      
 EE95				DiskVerify:
 EE95  BD F63C R		        mov     bp, sdverify
 EE98  EB 08			        jmp     short   DiskRead1
 EE9A				DiskWrite:
 EE9A  BD F6BC R		        mov     bp, sdwrite
 EE9D  EB 03			        jmp     short   DiskRead1
 EE9F				DiskRead:
 EE9F  BD F641 R		        mov     bp, sdread
 EEA2				DiskRead1:        
 EEA2  84 C0			        test    al, al
 EEA4  74 E7			        jz      short DiskReset
 EEA6  80 FA 80			        cmp     dl, 80h
 EEA9  75 4A			        jne     short notready
 EEAB  B4 04			        mov     ah, 4
 EEAD  F6 C1 3F			        test    cl, 3fh
 EEB0  74 18			        jz      short DiskReadend   ; bad sector 0
 EEB2  60			        pusha
 EEB3  B4 00			        mov     ah, 0
 EEB5  50			        push    ax
 EEB6  E8 0012			        call    HCStoLBA
 EEB9  59			        pop     cx
 EEBA  51			        push    cx        
 EEBB  FF D5			        call    bp              ; DX:AX sector, ES:BX buffer, CX=sectors, returns AX=read sectors
 EEBD  59			        pop     cx
 EEBE  2B C8			        sub     cx, ax
 EEC0  F7 D9			        neg     cx              ; CF=1 if cx != 0
 EEC2  C0 D4 03			        rcl     ah, 3           ; AH = 4*CF (sector not found / read error)
 EEC5  8E D8			        mov     ds, ax
 EEC7  61			        popa
 EEC8  8C D8			        mov     ax, ds
 EECA				DiskReadend:
 EECA  C3			        ret

 EECB				HCStoLBA:       ; CX = {cyl[7:0], cyl[9:8], sect[5:0]}, DH = head. Returns DX:AX LBA
 EECB  8A C5			        mov     al, ch
 EECD  8A E1			        mov     ah, cl
 EECF  C0 EC 06			        shr     ah, 6
 EED2  C1 EA 08			        shr     dx, 8
 EED5  6B D2 3F			        imul    dx, 63
 EED8  83 E1 3F			        and     cx, 3fh
 EEDB  03 CA			        add     cx, dx
 EEDD  49			        dec     cx
 EEDE  BA 3EC1			        mov     dx, 255*63
 EEE1  F7 E2			        mul     dx
 EEE3  03 C1			        add     ax, cx
 EEE5  83 D2 00			        adc     dx, 0
 EEE8  C3			        ret       
				;    unsigned int s = cs & 0x3f;
				;    unsigned int c = ((cs & 0xc0) << 2) | (cs >> 8);
				;    return (c*255l + h)*63l + s - 1l;

 EEE9				DiskFormat:
 EEE9				DiskInit:
 EEE9				DiskSeek:
 EEE9				DiskRst:
 EEE9				DiskReady:
 EEE9				DiskRecalibrate:
 EEE9				DiskDiag:
 EEE9				DiskExtSeek:
 EEE9  83 3E 0094 00		        cmp     word ptr HDSize, 0
 EEEE  74 05			        je      short notready
 EEF0  80 FA 80			        cmp     dl, 80h
 EEF3  74 98			        je      short DiskReset
 EEF5				notready:        
 EEF5  B4 AA			        mov     ah, 0aah        ; disk not ready
 EEF7  C3			        ret

 EEF8				DiskGetParams:
 EEF8  80 FA 80			        cmp     dl, 80h
 EEFB  B4 07			        mov     ah, 7
 EEFD  75 CB			        jne     short DiskReadend   ; ret
 EEFF  B3 00			        mov     bl, 0   ; ???
 EF01  A1 0094			        mov     ax, HDSize
 EF04  8B D0			        mov     dx, ax
 EF06  C1 E0 0A			        shl     ax, 10
 EF09  C1 EA 06			        shr     dx, 6
 EF0C  83 E8 1E			        sub     ax, 30
 EF0F  83 DA 00			        sbb     dx, 0
 EF12  B9 3EC1			        mov     cx, 63*255
 EF15  F7 F1			        div     cx
 EF17  48			        dec     ax
 EF18  3D 03FE			        cmp     ax, 3feh
 EF1B  76 03			        jbe     dgpok
 EF1D  B8 03FE			        mov     ax, 3feh
 EF20				dgpok:        
 EF20  86 C4			        xchg    al, ah
 EF22  C0 E0 06			        shl     al, 6
 EF25  0C 3F			        or      al, 3fh
 EF27  8B C8			        mov     cx, ax
 EF29  BA FE01			        mov     dx, 0fe01h
 EF2C  33 C0			        xor     ax, ax
 EF2E  C3			        ret        

 EF2F				DiskExtVerify:
 EF2F  BD F63C R		        mov     bp, sdverify
 EF32  EB 08			        jmp     short DiskExtRead1
 EF34				DiskExtWrite:
 EF34  BD F6BC R		        mov     bp, sdwrite
 EF37  EB 03			        jmp     short DiskExtRead1
 EF39				DiskExtRead:
 EF39  BD F641 R		        mov     bp, sdread
 EF3C				DiskExtRead1:
 EF3C  80 FA 80			        cmp     dl, 80h
 EF3F  75 B4			        jne     short notready
 EF41  06			        push    es
 EF42  50			        push    ax
 EF43  60			        pusha
 EF44  8B DC			        mov     bx, sp
 EF46  36: 8E 5F 1A		        mov     ds, ss:[bx+26]
 EF4A  8B 4C 02			        mov     cx, [si+2]
 EF4D  C4 5C 04			        les     bx, [si+4]
 EF50  8B 44 08			        mov     ax, [si+8]
 EF53  8B 54 0A			        mov     dx, [si+10]
 EF56  1E			        push    ds
 EF57  56			        push    si
 EF58  FF D5			        call    bp
 EF5A  5E			        pop     si
 EF5B  1F			        pop     ds
 EF5C  2B 44 02			        sub     ax, [si+2]
 EF5F  01 44 02			        add     [si+2], ax
 EF62  61			        popa
 EF63  58			        pop     ax
 EF64  1A E4			        sbb     ah, ah
 EF66  80 E4 04			        and     ah, 4
 EF69  07			        pop     es
 EF6A  C3			        ret

 EF6B				DiskExtGetParams:
 EF6B  80 FA 80			        cmp     dl, 80h
 EF6E  75 85			        jne     short notready
 EF70  50			        push    ax
 EF71  A1 0094			        mov     ax, HDSize   
 EF74  8B EC			        mov     bp, sp
 EF76  8E 5E 08			        mov     ds, [bp+8]
 EF79  33 ED			        xor     bp, bp
 EF7B  C7 04 001A		        mov     word ptr [si], 1ah      ; size
 EF7F  C7 44 02 000B		        mov     word ptr [si+2], 0bh    ; flags
 EF84  C7 44 04 03FF		        mov     word ptr [si+4], 1023   ; cylinders
 EF89  89 6C 06			        mov     word ptr [si+6], bp
 EF8C  C7 44 08 00FF		        mov     word ptr [si+8], 255    ; heads
 EF91  89 6C 0A			        mov     word ptr [si+10], bp
 EF94  C7 44 0C 003F		        mov     word ptr [si+12], 63     ; sectors/track
 EF99  89 6C 0E			        mov     word ptr [si+14], bp
 EF9C  89 44 10			        mov     word ptr [si+16], ax
 EF9F  C1 64 10 0A		        shl     word ptr [si+16], 10
 EFA3  C1 E8 06			        shr     ax, 6
 EFA6  89 44 12			        mov     word ptr [si+18], ax
 EFA9  89 6C 14			        mov     word ptr [si+20], bp
 EFAC  89 6C 16			        mov     word ptr [si+22], bp
 EFAF  C7 44 18 0200		        mov     word ptr [si+24], 512   ; bytes/sector
 EFB4  58			        pop     ax
 EFB5  B4 00			        mov     ah, 0
 EFB7  C3			        ret 

 EFB8				DiskReadSectBuffer:
 EFB8				DiskWriteSectBuffer:
 EFB8				DiskSetDASDType:
 EFB8				DiskSetMediaType:
 EFB8				DiskExtLock:
 EFB8				DiskExtEject:
 EFB8  B4 01			        mov     ah, 1       ; unsupported fn
 EFBA  C3			        ret

 EFBB				int13   endp


				OFFDX MACRO n
					IF n LE -3 OR n GE 3
						add		dx, n
					ENDIF
					IF n EQ -2
						dec		dx
					ENDIF 
					IF n EQ -1 or n EQ -2
						dec		dx
					ENDIF
					IF n EQ 1 or n EQ 2
						inc		dx
					ENDIF 
					IF n eq 2
						inc		dx
					ENDIF
				ENDM
				; --------------------- INT 14h - Serial port I/O ----------------
 = 0000				ComPort		equ		0
 = 0000				THR			equ		0	; Transmit holding buffer
 = 0000				RBR			equ		0	; Receive buffer
 = 0000				DLL			equ		0	; divisor latch low byte (DLAB = 1)
 = 0001				DLH			equ		1	; divisor latch high byte	(DLAB = 1)
 = 0001				IER			equ		1	; Interrupt enable register
 = 0003				LCR			equ		3	; line control register (DLAB, BrkEnable, PPP, S, LL)
 = 0005				LSR			equ		5	; line status register
 = 0006				MSR			equ		6	; Modem status register

				; AH=function number, AL=char sent or received, DX=zero based COM index. Preserve all registers except AX
 EFBB				int14 proc near
 EFBB  1E					push	ds
 EFBC  52					push	dx
 EFBD  56					push	si
 EFBE  6A 40					push	40h
 EFC0  1F					pop		ds
 EFC1  8B F2					mov		si, dx
 EFC3  03 F6					add		si, si
 EFC5  8B 14					mov		dx, ComPort[si]
						OFFDX	LCR
 EFC7  83 C2 03		     1			add		dx, LCR
 EFCA  8B F0					mov		si, ax
 EFCC  EC					in		al, dx
 EFCD  24 7F					and		al, 7fh		; clear DLAB bit
 EFCF  EE					out		dx, al
						OFFDX	LSR-LCR
 EFD0  42		     1			inc		dx
 EFD1  42		     1			inc		dx
 EFD2  8B C6					mov		ax, si
 EFD4  C1 EE 08					shr		si, 8
 EFD7  74 0D					jz		short SetCharFormat
 EFD9  4E					dec		si
 EFDA  74 43					jz		short STransmit
 EFDC  4E					dec		si
 EFDD  74 51					jz		short SReceive
 EFDF  4E					dec		si
 EFE0  74 33					jz		short GetPortStatus
				;		dec		si
				;		jz		short SetCharFormatExt
 EFE2				SExit:
 EFE2  5E					pop		si
 EFE3  5A					pop		dx
 EFE4  1F					pop		ds
 EFE5  CF					iret

				; ----- Set COM char format --------
				; AL = BBBPPSLL (BB=000..111 for baud 110,150,300,600,1200,2400,4800,9600)
				; returns LSR in AH and MSR in AL
 EFE6				SetCharFormat:		; DX = LSR
 EFE6  52					push	dx
 EFE7  51					push	cx
 EFE8  8A C8					mov		cl, al
 EFEA  8A E8					mov		ch, al
						OFFDX	LCR-LSR
 EFEC  4A		     1			dec		dx
 EFED  4A		     1			dec		dx
 EFEE  EC					in		al, dx
 EFEF  0C 80					or		al, 80h		; set DLAB=1
 EFF1  EE					out		dx, al
 EFF2  C0 E9 05					shr		cl, 5
 EFF5  B8 0417					mov		ax, 417h
 EFF8  74 05					jz		short Baud110
 EFFA  B8 0300					mov		ax, 300h
 EFFD  D3 E8					shr		ax, cl
 EFFF				Baud110:
						OFFDX	DLL-LCR
 EFFF  83 C2 FD		     1			add		dx, DLL-LCR
 F002  EE					out		dx, al		; set baud low
						OFFDX	DLH-DLL
 F003  42		     1			inc		dx
 F004  8A C4					mov		al, ah
 F006  EE					out		dx, al		; set baud high
						OFFDX	LCR-DLH
 F007  42		     1			inc		dx
 F008  42		     1			inc		dx
 F009  8A C5					mov		al, ch
 F00B  24 1F					and		al, 1fh
 F00D  EE					out		dx, al		; set format, DLAB=0

						OFFDX	IER-LCR
 F00E  4A		     1			dec		dx
 F00F  4A		     1			dec		dx
 F010  32 C0					xor		al, al
 F012  EE					out		dx, al		; disable all interrupts
 F013  59					pop		cx
 F014  5A					pop		dx

				; ----- get COM port status --------
 F015				GetPortStatus:			; DX = LSR
						OFFDX	MSR-LSR
 F015  42		     1			inc		dx
 F016  EC					in		al, dx		; read modem status
						OFFDX	LSR-MSR
 F017  4A		     1			dec		dx
 F018				GetPortStatus1:
 F018  8A E0					mov		ah, al
 F01A  EC					in		al, dx		; read line (port) status
 F01B  86 E0					xchg	ah, al
 F01D  EB C3					jmp		short SExit
						
				; ----- Transmit char to COM port --------
				; Waits for THRE(bit5 in LSR) and then sends AL. returns LSR in AH
 F01F				STransmit:			; DX = LSR
 F01F  52					push	dx
 F020  8A E0					mov		ah, al
 F022				STr1:
 F022  EC					in		al, dx
 F023  A8 20					test	al, 20h
 F025  74 FB					jz		short STr1
						OFFDX	THR-LSR
 F027  83 C2 FB		     1			add		dx, THR-LSR
 F02A  8A C4					mov		al, ah
 F02C  EE					out		dx, al
 F02D				STr2:
 F02D  5A					pop		dx
 F02E  EB E8					jmp		short GetPortStatus1

				; ----- receive char from COM port --------
				; Waits for RDA(bit0 in  LSR) and returns the received char in AL, and the LSR in AH
 F030				SReceive:			; DX = LSR
 F030  52					push	dx
 F031				SReceive1:
 F031  EC					in		al, dx
 F032  A8 01					test	al, 1
 F034  74 FB					jz		short SReceive1
						OFFDX	RBR-LSR
 F036  83 C2 FB		     1			add		dx, RBR-LSR
 F039  EC					in		al, dx
 F03A  EB F1					jmp		short Str2


				; ----- Set COM char format extended --------
				;SetCharFormatExt:
 F03C				int14 endp

				; --------------------- INT 15h - Extended services ----------------
 = ds:[98h]			UFPtr           equ     <ds:[98h]>
 = ds:[9ch]			WaitCount       equ     <ds:[9ch]>
 = ds:[0a0h]			UWaitFlag       equ     <ds:[0a0h]>
 = ds:[0a1h]			HandlerPtr      equ     <ds:[0a1h]> ; 4 bytes
 = ds:[0a5h]			DataBuffer      equ     <ds:[0a5h]> ; 3 bytes
 = ds:[067h]			DataCounter     equ     <ds:[067h]> ; 1 byte
 = ds:[068h]			PacketSize      equ     <ds:[068h]> ; 1 byte, 0->3bytes, 1->4bytes
 = 3B60				FreeXMSKb       equ     RAMSize*64 - 640 - 512 - 32	;total - DOS - VGA - BIOS

				; ------------ MovExt
 F03C				IncSeg: ; DX = segment port address
 F03C  75 25			        jnz     short SetSegExit
 F03E  ED			        in      ax, dx
 F03F  25 00FF			        and     ax, RAMSize - 1
 F042  40			        inc     ax
 F043  83 F8 12			        cmp     ax, 12h
 F046  75 02			        jne     short IncSeg1
 F048  33 C0			        xor     ax, ax
 F04A				IncSeg1:
 F04A  83 F8 0C			        cmp     ax, 0ch
 F04D  75 0B			        jne     short SetSeg2
 F04F				SetSeg: ; DX = segment port address, ax = logical segment (0..RAMSize-1)    
 F04F  25 00FF			        and     ax, RAMSize - 1
 F052  83 F8 0C			        cmp     ax, 0ch
 F055  72 0B			        jb      short SetSeg1
 F057  83 C0 06			        add     ax, 6
 F05A				SetSeg2:        
 F05A  3D 0100			        cmp     ax, RAMSize
 F05D  72 03			        jb      short SetSeg1
 F05F  2D 00F4			        sub     ax, RAMSize - 0ch
 F062				SetSeg1:
 F062  EF			        out     dx, ax          
 F063				SetSegExit:              
 F063  C3			        ret

 = 0001				MovSeg  equ     01h
 F064 0000			savess  dw      0
 F066 F06A R 0000		savesp  dw      MovExt, 0 ; tmp stack
				; Log(idx) to Phy(val) segment map (RAMSize segs): 0,1,2,3,4,5,6,7,8,9,a,b,12h,13h,...,RAMSize-2,RAMSize-1,c,d,e,f,10h,11h, then wrap to 0,1,2,...
 F06A				MovExt:
 F06A  06			        push    es
 F06B  1E			        push    ds
 F06C  60			        pusha
 F06D  FA			        cli
 F06E  2E: 8C 16 F064 R		        mov     cs:savess, ss
 F073  0E			        push    cs
 F074  17			        pop     ss
 F075  2E: 87 26 F066 R		        xchg    sp, cs:savesp
 F07A  BA 0082			        mov     dx, 80h + MovSeg + 1
 F07D  E3 72			        jcxz    short MovExt_exit
 F07F  06			        push    es
 F080  1F			        pop     ds
 F081  FC			        cld
 F082  8A 44 1C			        mov     al, [si+1ch]
 F085  8A 64 1F			        mov     ah, [si+1fh]
 F088  8A 5C 14			        mov     bl, [si+14h]
 F08B  8A 7C 17			        mov     bh, [si+17h]
 F08E  8B 7C 1A			        mov     di, [si+1ah]
 F091  8B 74 12			        mov     si, [si+12h]
 F094  E8 04B5			        call    flush   
 F097  E8 FFB5			        call    SetSeg      ; 02000h = destination, DX=82h
 F09A  4A			        dec     dx
 F09B  93			        xchg    ax, bx
 F09C  E8 FFB0			        call    SetSeg      ; 01000h = source, DX=81h
 F09F  68 1000			        push    MovSeg shl 12 
 F0A2  1F			        pop     ds
 F0A3  68 2000			        push    (MovSeg + 1) shl 12
 F0A6  07			        pop     es
 F0A7  33 DB			        xor     bx, bx
 F0A9  03 C9			        add     cx, cx
 F0AB  13 DB			        adc     bx, bx      ; BX:CX = bytes to transfer
				; move from 01000h:si to 02000h:di, 2*cx bytes
 F0AD				MovExtLoop:
 F0AD  42			        inc     dx          ; 82h
 F0AE  8B C6			        mov     ax, si
 F0B0  3B C7			        cmp     ax, di
 F0B2  77 02			        ja      short MovExt1
 F0B4  8B C7			        mov     ax, di
 F0B6				MovExt1:
 F0B6  F7 D8			        neg     ax
 F0B8  83 D3 FF			        adc     bx, -1
 F0BB  2B C8			        sub     cx, ax
 F0BD  83 DB 00			        sbb     bx, 0
 F0C0  91			        xchg    ax, cx      ; cx = bytes to move, bx:ax = bytes left for the next transfer
 F0C1  79 05			        jns     short MovExt2   ; ax <= bx:cx     
 F0C3  03 C8			        add     cx, ax
 F0C5  33 C0			        xor     ax, ax
 F0C7  43			        inc     bx
 F0C8				MovExt2:
 F0C8  A4			        movsb               ; if CX = 0 transfer 10000h bytes
 F0C9  49			        dec     cx
 F0CA  74 0F			        jz      short MovExt_next
 F0CC  F7 C6 0001		        test    si, 1       ; read align
 F0D0  74 02			        jz      short raligned
 F0D2  A4			        movsb
 F0D3  49			        dec     cx
 F0D4				raligned:
 F0D4  D1 E9			        shr     cx, 1
 F0D6  F3/ A5			        rep     movsw
 F0D8  73 01			        jnc     short MovExt_next
 F0DA  A4			        movsb
 F0DB				MovExt_next:
 F0DB  E8 046E			        call    flush
 F0DE  8B C8			        mov     cx, ax
 F0E0  0B C3			        or      ax, bx
 F0E2  74 0D			        jz      short MovExt_exit  ; finalized
 F0E4  85 FF			        test    di, di
 F0E6  E8 FF53			        call    incseg      ; does nothing if ZF == 0, dx = 8bh
 F0E9  4A			        dec     dx          ; 81h
 F0EA  85 F6			        test    si, si      
 F0EC  E8 FF4D			        call    incseg      ; dx = 81h
 F0EF  EB BC			        jmp     short MovExtLoop
 F0F1				MovExt_exit:
 F0F1  B8 0002			        mov     ax, MovSeg + 1
 F0F4  EF			        out     dx, ax      ; 82h
 F0F5  48			        dec     ax
 F0F6  4A			        dec     dx
 F0F7  EF			        out     dx, ax      ; 81h
 F0F8  2E: 8E 16 F064 R		        mov     ss, cs:savess
 F0FD  2E: 87 26 F066 R		        xchg    sp, cs:savesp
 F102  61			        popa
 F103  1F			        pop     ds
 F104  07			        pop     es
 F105  32 E4			        xor     ah, ah
 F107  EB 38			        jmp     short exit_ax
 F109				MovExtProxy:
 F109  E9 FF5E			        jmp     MovExt        

 F10C				int15:
 F10C  80 FC 4F			        cmp     ah, 4fh
 F10F  74 34			        je      short exit_iret
 F111  86 C4			        xchg    al, ah
 F113  3C 80			        cmp     al, 80h
 F115  72 27			        jb      short exit15; CF=1  for <80h
 F117  3C 83			        cmp     al, 83h
 F119  72 22			        jb      short done  ; no error for 80, 81, 82
 F11B  74 29			        je      short SetEventWait; 83
 F11D  3C 86			        cmp     al, 86h
 F11F  72 1D			        jb      short exit15; CF=1 for 84, 85
 F121  74 58			        je      short Wait1 ; 86
 F123  3C 88			        cmp     al, 88h
 F125  72 E2			        jb      short MovExtProxy ; 87
 F127  74 6B			        je      short ExtSize     ; 88
 F129  3C 90			        cmp     al, 90h
 F12B  72 11			        jb      short  exit15; CF=1 for 89..8f
 F12D  3C 92			        cmp     al, 92h
 F12F  72 0C			        jb      short done  ; no error for 90, 91
 F131  3C C0			        cmp     al, 0c0h
 F133  72 09			        jb      short exit15; CF=1 for 92..bf
 F135  74 62			        je      short GetConfig   ; c0
 F137  3C C2			        cmp     al, 0c2h
 F139  72 03			        jb      short exit15; CF=1 for c1
 F13B  74 65			        je      short Mouse ; c2
 F13D				done:
 F13D  F5			        cmc                 ; CF=1 for >c2
 F13E				exit15:
 F13E  B8 8600			        mov     ax, 8600h
 F141				exit_ax:        
 F141  FB			        sti
 F142  CA 0002			        retf    2           ; discard flags (need to keep CF)
 F145				exit_iret:
 F145  CF			        iret        

				; ------------ SetEventWait
 F146				SetEventWait:
 F146  1E			        push    ds
 F147  6A 40			        push    40h
 F149  1F			        pop     ds
 F14A  80 F4 01			        xor     ah, 1
 F14D  74 21			        jz      short cancel
 F14F  84 26 00A0		        test    ah, byte ptr UWaitFlag ; ah=1
 F153  75 22			        jnz     short busy  ; CF=0
 F155  B8 03E7			        mov     ax, 1000-1  ; 1ms
 F158  E7 70			        out     70h, ax     ; restart RTC timer
 F15A  89 1E 0098		        mov     UFPtr[0], bx
 F15E  8C 06 009A		        mov     UFPtr[2], es
 F162  03 C2			        add     ax, dx
 F164  83 D1 00			        adc     cx, 0
 F167  A3 009C			        mov     WaitCount[0], ax
 F16A  89 0E 009E		        mov     WaitCount[2], cx
 F16E  B4 01			        mov     ah, 1       ; wait in progress
 F170				cancel:
 F170  88 26 00A0		        mov     byte ptr UWaitFlag, ah   
 F174  CD 70			        int     70h
 F176  F9			        stc                 ; no error
 F177				busy:   
 F177  F5			        cmc                 ; eror        
 F178				nowait:
 F178  1F			        pop     ds
 F179  EB C3			        jmp     short exit15

				; ------------ Wait
 F17B				Wait1:
 F17B  06			        push    es
 F17C  53			        push    bx
 F17D  B8 8300			        mov     ax, 8300h
 F180  6A 4A			        push    4ah
 F182  07			        pop     es
 F183  33 DB			        xor     bx, bx      ; user wait flag address=0040:00a0
 F185  CD 15			        int     15h         ; returns with IF = 1
 F187  72 07			        jc      short wbusy
 F189				wloop:        
 F189  F4			        hlt   
 F18A  26: F6 07 80		        test    byte ptr es:[bx], 80h
 F18E  74 F9			        jz      short wloop
 F190				wbusy:        
 F190  5B			        pop     bx
 F191  07			        pop     es
 F192  EB AA			        jmp     short exit15
				        

				; ------------ ExtSize
 F194				ExtSize:
 F194  B8 3B60			        mov     ax, FreeXMSKb
 F197  EB A8			        jmp     short exit_ax
				        
				; ------------ GetConfig
 F199				GetConfig:
 F199  33 C0			        xor     ax, ax
 F19B  0E			        push    cs
 F19C  07			        pop     es
 F19D  BB F29A R		        mov     bx, offset SysParams
 F1A0  EB 9F			        jmp     short exit_ax
				        
				; ------------ Mouse 
 F1A2				Mouse:
 F1A2  1E			        push    ds
 F1A3  52			        push    dx
 F1A4  6A 40			        push    40h
 F1A6  1F			        pop     ds
 F1A7  F6 06 0010 04		        test    byte ptr EquipmentWord, 4 ; ps2 mouse equipement word
 F1AC  75 16			        jnz     short mouse_present
 F1AE				if_err:
 F1AE  B8 03A7			        mov     ax, 03a7h   ; interface error (no mouse present)
 F1B1  E6 64			        out     64h, al     ; disable mouse
 F1B3				errexit:        
 F1B3  F9			        stc                 ; error
 F1B4				exitok:        
 F1B4  9C			        pushf               ; save CF
 F1B5  E4 A1			        in      al, 0a1h
 F1B7  24 EF			        and     al, not 10h     
 F1B9  E6 A1			        out     0a1h, al    ; enable mouse interrupts
 F1BB  E8 0381			        call    enableKbIfPresent
 F1BE  9D			        popf
 F1BF  5A			        pop     dx
 F1C0  1F			        pop     ds
 F1C1  E9 FF7D			        jmp     exit_ax
 F1C4				mouse_present:
 F1C4  8A C4			        mov     al, ah                                  
 F1C6  B4 01			        mov     ah, 1       ; invalid function
 F1C8  3C 07			        cmp     al, 7
 F1CA  77 E7			        ja      short errexit
 F1CC  50			        push    ax
 F1CD  E4 A1			        in      al, 0a1h
 F1CF  0C 10			        or      al, 10h     
 F1D1  E6 A1			        out     0a1h, al    ; disable mouse interrupts
 F1D3  FB			        sti                 ; allow interrupts for a short time, to flush possible pending KB/mouse requests
 F1D4  B0 AD			        mov     al, 0adh
 F1D6  E6 64			        out     64h, al     ; disable kb interface
 F1D8  58			        pop     ax
 F1D9  3C 01			        cmp     al, 1
 F1DB  FA			        cli                 ; from now on we are working with ints disabled, as the following code is highly non re-entrant
 F1DC  72 1C			        jb      short en_dis
 F1DE  74 33			        je      short reset
 F1E0  3C 03			        cmp     al, 3
 F1E2  72 40			        jb      short sampling
 F1E4  74 5D			        je      short resolution
 F1E6  3C 05			        cmp     al, 5
 F1E8  72 63			        jb      short gettype
 F1EA  74 27			        je      short reset
 F1EC  3C 06			        cmp     al, 6
 F1EE  74 75			        je      short extend

				; ------------- set handler
 F1F0  89 1E 00A1		        mov     HandlerPtr[0], bx
 F1F4  8C 06 00A3		        mov     HandlerPtr[2], es
 F1F8  EB 15			        jmp     short exit_success1        

				; ------------- enable/disable
 F1FA				en_dis:
 F1FA  B8 02F5			        mov     ax, 02f5h   ; ah = invalid input
 F1FD  2A C7			        sub     al, bh
 F1FF  38 E7			        cmp     bh, ah
 F201  73 B0			        jnc     short errexit
 F203  8A E0			        mov     ah, al
 F205  E8 0326			        call    sendcmd     ; enable/disable data reporting (CF = 1)
 F208				if_err1:        
 F208  72 A4			        jc      short if_err
 F20A				exit_success:
 F20A  C6 06 0067 00		        mov     byte ptr DataCounter, 0
 F20F				exit_success1:
 F20F  32 E4			        xor     ah, ah      ; success
 F211  EB A1			        jmp     short exitok

				; ------------- reset
 F213				reset:
 F213  B4 F6			        mov     ah, 0f6h    ; set defaults
 F215  F9			        stc                 ; mouse command
 F216  E8 0315			        call    sendcmd     
 F219  72 93			        jc      short if_err
 F21B  BB 00AA			        mov     bx, 00aah
 F21E  88 3E 0068		        mov     byte ptr PacketSize, bh ; 3bytes packet
 F222  EB E6			        jmp     short exit_success

				; ------------- sampling
 F224				sampling:
 F224  80 FF 06			        cmp     bh, 6
 F227				badparam:
 F227  B4 02			        mov     ah, 2       ; invalid input
 F229  77 88			        ja      short errexit
 F22B  C1 EB 08			        shr     bx, 8
 F22E  2E: 8A A7 F293 R		        mov     ah, cs:sample_tbl[bx]
 F233  50			        push    ax
 F234  B4 F3			        mov     ah, 0f3h    ; st sample rate
 F236				send2c:
 F236  F9			        stc
 F237  E8 02F4			        call    sendcmd              
 F23A  58			        pop     ax
 F23B  72 CB			        jc      short if_err1
 F23D				send1c:
 F23D  F9			        stc
 F23E  E8 02ED			        call    sendcmd
 F241  EB C5			        jmp     short if_err1

				; ------------- resolution
 F243				resolution:
 F243  80 FF 03			        cmp     bh, 3
 F246  77 DF			        ja      short badparam
 F248  53			        push    bx
 F249  B4 E8			        mov     ah, 0e8h    ; set resolution
 F24B  EB E9			        jmp     short send2c

				; ------------- gettype
 F24D				gettype:
 F24D  B4 F2			        mov     ah, 0f2h
 F24F  F9			        stc
 F250  E8 02DB			        call    sendcmd
 F253  72 B3			        jc      short if_err1
 F255  E8 02BC			        call    getps2byte
 F258  72 AE			        jc      short if_err1
 F25A  8A F8			        mov     bh, al
 F25C  F6 D8			        neg     al          ; CF=1 if al != 0
 F25E  12 C7			        adc     al, bh
 F260  A2 0068			        mov     byte ptr PacketSize, al ; 3 or 4 bytes packet
 F263  EB A5			        jmp     short exit_success
				        
				; ------------- extended commands
 F265				extend:
 F265  84 FF			        test    bh, bh
 F267  75 1F			        jnz     short setscaling
 F269  B4 E9			        mov     ah, 0e9h    ; status request
 F26B  F9			        stc
 F26C  E8 02BF			        call    sendcmd
 F26F  72 97			        jc      short if_err1
 F271  E8 02A0			        call    getps2byte
 F274  72 92			        jc      short if_err1
 F276  8A D8			        mov     bl, al
 F278  E8 0299			        call    getps2byte
 F27B  72 8B			        jc      short if_err1
 F27D  8A C8			        mov     cl, al
 F27F  E8 0292			        call    getps2byte
 F282  72 84			        jc      short if_err1
 F284  5A			        pop     dx  
 F285  50			        push    ax          ; replace dx on stack
 F286  EB 82			        jmp     short exit_success
 F288				setscaling:    
 F288  80 FF 02			        cmp     bh, 2
 F28B  77 9A			        ja      short badparam
 F28D  B4 E5			        mov     ah, 0e5h    ; set scaling 1:1 or 2:1
 F28F  02 E7			        add     ah, bh
 F291  EB AA			        jmp     short send1c

 F293 0A 14 28 3C 50 64		sample_tbl  db  10, 20, 40, 60, 80, 100, 200
       C8
 F29A 08 00 FC 00 00		SysParams   db  8, 0, 0fch, 0, 0
				;--------------------------------------------------------------------------
				; Feature byte 1
				; b7: 1=DMA channel 3 used by hard disk
				; b6: 1=2 interrupt controllers present
				; b5: 1=RTC present
				; b4: 1=BIOS calls int 15h/4Fh every key
				; b3: 1=wait for extern event supported (Int 15h/41h)
				; b2: 1=extended BIOS data area used
				; b1: 0=AT or ESDI bus, 1=MicroChannel
				; b0: 1=Dual bus (MicroChannel + ISA)
				;--------------------------------------------------------------------------
 F29F  10			            db      10h
				;--------------------------------------------------------------------------
				; Feature byte 2
				; b7: 1=32-bit DMA supported
				; b6: 1=int16h, function 9 supported
				; b5: 1=int15h/C6h (get POS data) supported
				; b4: 1=int15h/C7h (get mem map info) supported
				; b3: 1=int15h/C8h (en/dis CPU) supported
				; b2: 1=non-8042 kb controller
				; b1: 1=data streaming supported
				; b0: reserved
				;--------------------------------------------------------------------------
 F2A0  44			            db      44h
				;--------------------------------------------------------------------------
				; Feature byte 3
				; b7: not used
				; b6: reserved
				; b5: reserved
				; b4: POST supports ROM-to-RAM enable/disable
				; b3: SCSI on system board
				; b2: info panel installed
				; b1: Initial Machine Load (IML) system - BIOS on disk
				; b0: SCSI supported in IML
				;--------------------------------------------------------------------------
 F2A1  00			            db      0
				;--------------------------------------------------------------------------
				; Feature byte 4
				; b7: IBM private
				; b6: EEPROM present
				; b5-3: ABIOS presence (011 = not supported)
				; b2: private
				; b1: memory split above 16Mb supported
				; b0: POSTEXT directly supported by POST
				;--------------------------------------------------------------------------
 F2A2  00			            db      0
				;--------------------------------------------------------------------------
				; Feature byte 5 (IBM)
				; b1: enhanced mouse
				; b0: flash EPROM
				;--------------------------------------------------------------------------
 F2A3  00			            db      0                                                


				; --------------------- INT 16h - keyboard interface ----------------
				;       AH      Description
				;       --      ------------------------------------------------
				;       00h     Get a key from the keyboard, return code in AX.
				;       01h     Test for available key, ZF=1 if none, ZF=0 and
				;               AX contains next key code if key available.
				;       02h     Get shift status. Returns shift key status in AL.
				;       03h     Set Autorepeat rate. BH=0,1,2,3 (delay time in quarter seconds), BL=0..1Fh for 30 char/sec to 2 char/sec repeat rate.
				;       05h     Store scan code (in CX) in the type ahead buffer.
				;       10h     Get a key (same as 00h in this implementation).
				;       11h     Test for key (same as 01h).
				;       12h     Get extended key status. Returns status in AX.

 = ds:[19h]			AltKpd          equ     <ds:[19h]>
 = ds:[1ah]			HeadPtr         equ     <ds:[1ah]>
 = ds:[1ch]			TailPtr         equ     <ds:[1ch]>
 = ds:[80h]			Buffer          equ     <ds:[80h]>;1eh
 = ds:[82h]			EndBuf          equ     <ds:[82h]>;3eh

 F2A4				int16 proc near
 F2A4  1E			        push    ds
 F2A5  56			        push    si
 F2A6  6A 40			        push    40h
 F2A8  1F			        pop     ds
 F2A9  86 C4			        xchg    al, ah          ;shorter opcodes for al than ah
 F2AB  48			        dec     ax
 F2AC  A8 EF			        test    al, 0EFh        ;Check for 01h and 11h
 F2AE  74 3E			        jz      short TestKey   ;TestKey does not need cld
 F2B0  40			        inc     ax
 F2B1  FC			        cld
 F2B2  A8 EF			        test    al, 0EFh        ;Check for 0h and 10h
 F2B4  74 1C			        jz      short GetKey
 F2B6  3C 03			        cmp     al, 3           ;Check for 02h and 03h
 F2B8  72 78			        jb      short GetStatus
 F2BA  74 7B			        je      short SetAutoRpt   
 F2BC  3C 05			        cmp     al, 5           ;Check for StoreKey function.
 F2BE  74 3D			        je      short StoreKey
 F2C0  3C 09			        cmp     al, 9           ;Get KB functionality
 F2C2  74 08			        je      short kbfunc     
 F2C4  3C 12			        cmp     al, 12h         ;Extended status call
 F2C6  74 56			        je      short ExtStatus
 F2C8  3C 92			        cmp     al, 92h         ;stupid keyb.com 
 F2CA  75 02			        jne     short Exit
 F2CC				kbfunc:
 F2CC  B0 24			        mov     al, 24h         ;AL=20h (fn 10h, 12h supported, set typematic supported)        
 F2CE				Exit:        
 F2CE  5E			        pop     si
 F2CF  1F			        pop     ds
 F2D0  CF			        iret                    ; unknown function, Restores flags.

 F2D1				GetKey1:                        ; wait for interrupt
 F2D1  F4			        hlt
 F2D2				GetKey: ; ----------- fn 00h, 10h
 F2D2  B4 11			        mov     ah, 11h
 F2D4  CD 16			        int     16h             ;See if key is available (IF becomes 1 after this int)
 F2D6  74 F9			        jz      short GetKey1   ;Wait for keystroke.
 F2D8  FA			        cli                     ;Critical region! Ints off.
 F2D9  8B 36 001A		        mov     si, HeadPtr     ;Ptr to next character.
 F2DD  AD			        lodsw                   ;Get the character, Bump up HeadPtr
 F2DE  3B 36 0082		        cmp     si, EndBuf
 F2E2  72 04			        jb      short noWrap
 F2E4  8B 36 0080		        mov     si, Buffer
 F2E8				noWrap:             
 F2E8  89 36 001A		        mov     HeadPtr, si
 F2EC  EB E0			        jmp     short Exit

 F2EE				TestKey: ; ---------- fn 01h
 F2EE  8B 36 001A		        mov     si, HeadPtr
 F2F2  3B 36 001C		        cmp     si, TailPtr     ;ZF=1, if empty buffer
 F2F6  AD			        lodsw                   ;BIOS returns avail keycode.
 F2F7  FB			        sti                     ;Ints back on.
 F2F8  5E			        pop     si
 F2F9  1F			        pop     ds
 F2FA  CA 0002			        retf    2               ;Pop flags (ZF is important!)

 F2FD				StoreKey: ; ---------- fn 05h - Inserts the value in CX into the type ahead buffer.  
 F2FD  8B 36 001C		        mov     si, TailPtr     ;Address where we can put next key code.
 F301  89 0C			        mov     [si], cx        ;Store the key code away
 F303  46			        inc     si
 F304  46			        inc     si              ;Move on to next entry in buf
 F305  3B 36 0082		        cmp     si, EndBuf
 F309  72 04			        jb      short NoWrap1
 F30B  8B 36 0080		        mov     si, Buffer
 F30F				 NoWrap1:
 F30F  B0 01			        mov     al, 1           ;no room
 F311  3B 36 001A		        cmp     si, HeadPtr     ;Data overrun?
 F315  74 B7			        je      short Exit      ;if so, ignore key entry.
 F317  89 36 001C		        mov     TailPtr, si
 F31B  48			        dec     ax              ;al=0
 F31C  EB B0			        jmp     short Exit       

 F31E				ExtStatus: ; ------- fn 12h - Retrieve the extended keyboard status and return it in AH, and the standard keyboard status in AL.    
 F31E  A0 0018			        mov     al, KbdFlags2
 F321  24 77			        and     al, 01110111b   ;Clear final sysreq field, and final right alt bit.
 F323  A8 04			        test    al, 100b        ;Test cur sysreq bit.
 F325  74 02			        jz      short NoSysReq  ;Skip if it's zero.
 F327  2C 84			        sub     al, 10000100b   ;Set final sysreq bit, clear final right ctl bit.
 F329				NoSysReq:
 F329  8A 26 0096		        mov     ah, KbdFlags3
 F32D  80 E4 0C			        and     ah, 1100b       ;Grab rt alt/ctrl bits.
 F330  0A E0			        or      ah, al          ;Merge into AH.

 F332				GetStatus: ; --------- fn 02h     
 F332  A0 0017			        mov     al, KbdFlags1   ;Just return Std Status.
 F335				Exit1:
 F335  EB 97			        jmp     short Exit

 F337				SetAutoRpt: ; ------ fn 03h
 F337  80 FC 05			        cmp     ah, 5
 F33A  75 92			        jne     short Exit
 F33C  52			        push    dx
 F33D  C0 E7 05			        shl     bh, 5
 F340  80 E3 1F			        and     bl, 1fh
 F343  0A DF			        or      bl, bh
 F345  80 E3 7F			        and     bl, 7fh
 F348  B4 00			        mov     ah, 0           ; wait LED update progress to finalize
 F34A  E8 0028			        call    WaitFlag        ; leaves with IF=0
 F34D  72 23			        jc      short timeout
 F34F  80 0E 0097 08		        or      byte ptr KbdFlags4, SetRepeat    ; set auto repeat in progress
 F354  B4 F3			        mov     ah, 0f3h        ; set typematic rate and delay
 F356  53			        push    bx
 F357  32 DB			        xor     bl, bl          ; send to kb
 F359  E8 0193			        call    sendps2byte
 F35C  5B			        pop     bx
 F35D  72 0E			        jc      short timeout1  ; send timeout
 F35F  B4 18			        mov     ah, SetRepeat or AckReceived ; test if ACK received
 F361  E8 0011			        call    WaitFlag
 F364  72 07			        jc      short timeout1
 F366  8A E3			        mov     ah, bl
 F368  32 DB			        xor     bl, bl          ; send to kb
 F36A  E8 0182			        call    sendps2byte     ; send data
 F36D				timeout1:
 F36D  80 26 0097 F7		        and     byte ptr KbdFlags4, not SetRepeat   
 F372				timeout:
 F372  5A			        pop     dx
 F373  EB C0			        jmp     short Exit1


 F375				WaitFlag:   ; ah = desired KbdFlags4 & (AckReceived | LEDUpdate | SetRepeat)
 F375  BA 03DA			        mov     dx, 3dah
 F378  B7 C8			        mov     bh, 8*25    ; wait for max 25 * VGA frame time
 F37A				wf_loop:
 F37A  FA			        cli
 F37B  A0 0097			        mov     al, KbdFlags4
 F37E  24 58			        and     al, AckReceived or LEDUpdate or SetRepeat
 F380  38 E0			        cmp     al, ah
 F382  74 0A			        je      short wf_ok ; flag ok, CF=0
 F384  FB			        sti
 F385  EC			        in      al, dx      ; get vblank
 F386  32 C7			        xor     al, bh
 F388  24 08			        and     al, 8h
 F38A  2A F8			        sub     bh, al
 F38C  73 EC			        jnc     short wf_loop     ; IBF - buffer full, no timeout
 F38E				wf_ok:
 F38E  C3			        ret
 F38F				int16 endp

				; --------------------- INT 18h - BIOS Basic ------------------
 F38F				int18 proc near
 F38F  0E			        push    cs
 F390  07			        pop     es
 F391  BE F3C7 R		        mov     si, offset booterrmsg
 F394  E8 01F3			        call    prts
 F397  E8 01B2					call	flush

				;-------------- RS232 bootstrap
 F39A  B0 B4			        mov     al, 0b4h
 F39C  E6 43			        out     43h, al
 F39E  B8 F000			        mov     ax, 0f000h
 F3A1  E6 42			        out     42h, al
 F3A3  E6 42			        out     42h, al      ; 18Hz PIT CH2
 F3A5  E7 01					out		1, ax		; disable auto flush on vblank (bit0)
 F3A7  8E D8				  mov ds,ax
 F3A9  8E C0				  mov es,ax

 F3AB  BE 0100			        mov si,100h
 F3AE  E8 0112				  call srecb
 F3B1  FA			        cli
 F3B2  8A FC				  mov bh,ah
 F3B4  E8 010C				  call srecb
 F3B7  8A DC				  mov bl,ah
 F3B9				sloop:	
 F3B9  E8 0107				  call srecb
 F3BC  88 24				  mov [si],ah
 F3BE  46				  inc si
 F3BF  4B				  dec bx
 F3C0  75 F7				  jnz short sloop
 F3C2  EA				  db 0eah
 F3C3  0100 F000		        dw 100h,0f000h

 F3C7 4E 6F 20 62 6F 6F		booterrmsg db   'No boot device available, waiting on RS232 (115200bps, f000:100) ...', 13, 10, 0
       74 20 64 65 76 69
       63 65 20 61 76 61
       69 6C 61 62 6C 65
       2C 20 77 61 69 74
       69 6E 67 20 6F 6E
       20 52 53 32 33 32
       20 28 31 31 35 32
       30 30 62 70 73 2C
       20 66 30 30 30 3A
       31 30 30 29 20 2E
       2E 2E 0D 0A 00
 F40E				int18 endp

				; --------------------- INT 19h - OS Bootstrap loader ------------------
 F40E				int19 proc near
 F40E  B8 0201			        mov     ax, 201h
 F411  B9 0001			        mov     cx, 1
 F414  BA 0080			        mov     dx, 80h
 F417  6A 00			        push    0
 F419  07			        pop     es
 F41A  BB 7C00			        mov     bx, 7c00h
 F41D  CD 13			        int     13h
 F41F  72 05			        jc      int19err
 F421  EA			        db      0eah
 F422  7C00 0000		        dw      7c00h, 0     ; jmp far 0000h:7c00h
 F426				int19err:
 F426  CD 18			        int     18h
 F428				int19 endp


				; --------------------- INT 1ah - Get System Time ------------------
 F428				int1a proc near
 F428  1E			        push    ds
 F429  6A 40			        push    40h
 F42B  1F			        pop     ds
 F42C  80 FC 01			        cmp     ah, 1
 F42F  77 12			        ja      clockexit
 F431  74 16			        je      setclock
 F433  8B 16 006C		        mov     dx, ds:[6ch]    ; read clock
 F437  8B 0E 006E		        mov     cx, ds:[6eh]
 F43B  A0 0070			        mov     al, ds:[70h]
 F43E				clockexit1:
 F43E  C6 06 0070 00		        mov     byte ptr ds:[70h], 0
 F443				clockexit:
 F443  F5			        cmc     ; CF = 1 on error
 F444  1F			        pop     ds
 F445  FB			        sti
 F446  CA 0002			        retf    2

 F449				setclock:
 F449  89 16 006C		        mov     ds:[6ch], dx
 F44D  89 0E 006E		        mov     ds:[6eh], cx
 F451  F9			        stc
 F452  EB EA			        jmp     short clockexit1    
 F454				int1a endp


				; --------------------- INT 70h - RTC ------------------
 F454				int70 proc near
 F454  1E			        push    ds
 F455  6A 40			        push    40h
 F457  1F			        pop     ds
 F458  F6 06 00A0 01		        test    byte ptr UWaitFlag, 1    ; is wait in progress?
 F45D  74 1B			        jz      short exit
 F45F  81 2E 009C 03E8		        sub     word ptr WaitCount[0], 1000
 F465  83 1E 009E 00		        sbb     word ptr WaitCount[2], 0
 F46A  73 0E			        jnc     short exit
 F46C  C6 06 00A0 00		        mov     byte ptr UWaitFlag, 0
 F471  53			        push    bx
 F472  C5 1E 0098		        lds     bx, UFPtr
 F476  80 0F 80			        or      byte ptr [bx], 80h
 F479  5B			        pop     bx
 F47A				exit: 
 F47A  1F			        pop     ds
 F47B  CF			        iret
 F47C				int70 endp

				        
				; --------------------- INT 74h - mouse ------------------
 F47C				int74 proc near
 F47C  FC			        cld
 F47D  60			        pusha
 F47E  1E			        push    ds
 F47F  6A 40			        push    40h
 F481  1F			        pop     ds
 F482  B4 00			        mov     ah, 0
 F484  E4 60			        in      al, 60h
 F486  8B D8			        mov     bx, ax
 F488  FE 06 0067		        inc     byte ptr DataCounter
 F48C  A0 0067			        mov     al, DataCounter
 F48F  8B F0			        mov     si, ax
 F491  2C 03			        sub     al, 3
 F493  77 0C			        ja      short docall
 F495  88 9C 00A4		        mov     DataBuffer[si-1], bl
 F499  3A 06 0068		        cmp     al, PacketSize
 F49D  75 21			        jne     short nocall
 F49F  B3 00			        mov     bl, 0
 F4A1				docall:
 F4A1  88 3E 0067		        mov     byte ptr DataCounter, bh    ; BH=0
 F4A5  BE 00A3			        mov     si, offset DataBuffer-2
 F4A8  AD			        lodsw
 F4A9  0B 44 FC			        or      ax, [si-4]
 F4AC  74 12			        jz      short nocall
 F4AE  FB			        sti
 F4AF  06			        push    es
 F4B0  B4 00			        mov     ah, 0
 F4B2  AC			        lodsb
 F4B3  50			        push    ax
 F4B4  AC			        lodsb
 F4B5  50			        push    ax
 F4B6  AC			        lodsb
 F4B7  50			        push    ax
 F4B8  53			        push    bx
 F4B9  FF 5C F9			        call    far ptr [si-7]
 F4BC  83 C4 08			        add     sp, 8
 F4BF  07			        pop     es
 F4C0				nocall:        
 F4C0  1F			        pop     ds
 F4C1  61			        popa
 F4C2  CF			        iret
 F4C3				int74 endp


				; ----------------  serial receive byte 115200 bps --------------
 F4C3  B4 80			srecb:  mov     ah, 80h
 F4C5  BA 03DA			        mov     dx, 3dah
 F4C8  B9 FA52			        mov     cx, -5aeh ; (half start bit)
 F4CB  EC			srstb:  in      al, dx
 F4CC  C0 E8 02				  shr     al, 2
 F4CF  72 FA				  jc      short srstb
 F4D1  E4 42			        in      al, 42h ; lo counter
 F4D3  02 E8			        add     ch, al
 F4D5  E4 42			        in      al, 42h ; hi counter, ignore
 F4D7				l1:
 F4D7  E8 0008			        call    dlybit
 F4DA  EC				  in      al, dx
 F4DB  C0 E8 02			        shr     al, 2
 F4DE  D0 DC				  rcr     ah, 1
 F4E0  73 F5				  jnc     short l1
 F4E2				dlybit:
 F4E2  81 E9 0A5B		        sub     cx, 0a5bh  ;  (full bit)
 F4E6				dly1:
 F4E6  E4 42			        in      al, 42h
 F4E8  38 E8			        cmp     al, ch
 F4EA  E4 42			        in      al, 42h
 F4EC  75 F8			        jnz     short dly1
 F4EE  C3			        ret

				; -------------------- KB/Mouse access ----------------
 F4EF				sendps2byte proc near   ; ah=data, bl!=0 for mouse, 0 for kb. returns cf=1 if timeout (al = 8)
				; changes BH, AL
 F4EF  52			        push    dx
 F4F0  BA 03DA			        mov     dx, 3dah
 F4F3  B7 28			        mov     bh, 8*5
 F4F5				sps2b2:
 F4F5  E4 64			        in      al, 64h
 F4F7  A8 02			        test    al, 2
 F4F9  74 0B			        jz      short sps2b1; buffer empty
 F4FB  EC			        in      al, dx      ; get vblank
 F4FC  32 C7			        xor     al, bh
 F4FE  24 08			        and     al, 8h
 F500  2A F8			        sub     bh, al
 F502  73 F1			        jnc     short sps2b2; IBF - buffer full, no timeout
 F504  EB 0C			        jmp     short exit  ; timeout, CF=1
 F506				sps2b1:
 F506  84 DB			        test    bl, bl      ; CF=0
 F508  74 04			        jz      short sps2_kb
 F50A  B0 D4			        mov     al, 0d4h    ; next mouse
 F50C  E6 64			        out     64h, al
 F50E				sps2_kb:
 F50E  8A C4			        mov     al, ah
 F510  E6 60			        out     60h, al     ; send byte
 F512				exit:        
 F512  5A			        pop     dx
 F513  C3			        ret
 F514				sendps2byte endp

 F514				getps2byte proc near    ; returns al=data, zf=0 for mouse, 1 for kb, cf=1 if timeout (al=8)
				; changes BH, DX, AL
 F514  BA 03DA			        mov     dx, 3dah
 F517  B7 28			        mov     bh, 8*5
 F519				gps2b2:
 F519  E4 64			        in      al, 64h
 F51B  A8 01			        test    al, 1
 F51D  75 0A			        jnz     short gps2b1     ; OBF (buffer full), continue
 F51F  EC			        in      al, dx     ; get vblank
 F520  32 C7			        xor     al, bh
 F522  24 08			        and     al, 8
 F524  2A F8			        sub     bh, al
 F526  73 F1			        jnc     short gps2b2     ; buffer empty, no timeout
 F528  C3			        ret                ; timeout, CF=1
 F529				gps2b1:
 F529  A8 20			        test    al, 20h    ; CF=0, ZF <- !MOBF
 F52B  E4 60			        in      al, 60h    ; read byte (if IF=1, this data may be invalid)
 F52D  C3			        ret
 F52E				getps2byte endp

 F52E				sendcmd proc near     ; ah = command, CF=1 for mouse, CF=0 for kb. returns CF=1 on error
 F52E  1A DB			        sbb     bl, bl      ; bl <- CF
 F530  E8 FFBC			        call    sendps2byte 
 F533  72 09			        jc      short exit
 F535				retry:        
 F535  E8 FFDC			        call    getps2byte
 F538  72 04			        jc      short exit        
 F53A  3C FA			        cmp     al, 0fah    ; ack (returns CF=1 on error, when al=8)
 F53C  75 F7			        jne     short retry
 F53E				exit:
 F53E  C3			        ret
 F53F				sendcmd endp

 F53F				enableKbIfPresent proc near ; input DS = 40h
				; modify AL, flags
 F53F  F6 06 0096 10		        test    byte ptr KbdFlags3, 10h
 F544  74 04			        jz      short noenablekb
 F546  B0 AE			        mov     al, 0aeh
 F548  E6 64			        out     64h, al     ; enable kb interface
 F54A				noenablekb:        
 F54A  C3			        ret
 F54B				enableKbIfPresent endp

				; ----------------------- default interrupt handler ---------------
 F54B				defint  proc near
 F54B  CF			        iret
 F54C				defint  endp             

				; ------------------------------- flush --------------------------
 F54C				flush:
 F54C  2E: 8F 06 F56D R		        pop     cs:flushret
 F551				flush_nostack:        
 F551  2E: 89 1E F56F R		        mov     cs:flushbh, bx
 F556  BB 4000			        mov     bx, 4000h       ; flush all cache lines
 F559				flush1:        
 F559  2E: 84 9F BF00		        test    bl, cs:[bx + 0bf00h]
 F55E  83 EB 40			        sub		bx, 40h
 F561  75 F6			        jnz     short flush1
 F563  2E: 8B 1E F56F R		        mov     bx, cs:flushbh
 F568  2E: FF 26 F56D R		        jmp     word ptr cs:flushret
 F56D 0000			flushret dw 0
 F56F 0000			flushbh  dw 0          

				; ------------------------------- misc --------------------------
 F571				dispAX: 
 F571  52			        push    dx
 F572  33 D2			        xor     dx, dx
 F574  2E: F7 36 F588 R		        div     word ptr cs:ten
 F579  85 C0			        test    ax, ax
 F57B  74 03			        jz      dispAX1
 F57D  E8 FFF1			        call    dispAX
 F580				dispAX1:
 F580  92			        xchg    ax, dx
 F581  05 0E30			        add     ax, 0e00h + '0'
 F584  CD 10			        int     10h
 F586  5A			        pop     dx
 F587  C3			        ret        
 F588 000A			ten     dw      10

 F58A				prts:   ; es:si = string
 F58A  B4 0E			        mov     ah, 0eh    
 F58C  26: AC			        lodsb   es:[si]
 F58E  0A C0			        or      al, al
 F590  74 04			        jz      short prtse
 F592  CD 10			        int     10h
 F594  EB F4			        jmp     short prts
 F596				prtse:
 F596  C3			        ret



				;---------------------  read/write byte ----------------------
 F597  B0 FF			sdrb:   mov al,0ffh
 F599				sdsb:               ; in AL=byte, DX = 03dah, out AX=result
 F599  EE			        out     dx, al
 F59A  03 C0			        add     ax, ax
 F59C  EE			        out     dx, al
 F59D  03 C0			        add     ax, ax
 F59F  EE			        out     dx, al
 F5A0  03 C0			        add     ax, ax
 F5A2  EE			        out     dx, al
 F5A3  03 C0			        add     ax, ax
 F5A5  EE			        out     dx, al
 F5A6  03 C0			        add     ax, ax
 F5A8  EE			        out     dx, al
 F5A9  03 C0			        add     ax, ax
 F5AB  EE			        out     dx, al
 F5AC  03 C0			        add     ax, ax
 F5AE  EE			        out     dx, al
 F5AF  ED			        in      ax, dx
 F5B0  C3			        ret

				;---------------------  write block ----------------------
 F5B1				sdwblk proc near              ; in SI=data ptr, DX=03dah, CX=size
 F5B1  D1 E9			        shr     cx, 1
 F5B3				sdwblk1:
 F5B3  AC			        lodsb
 F5B4  EE			        out     dx, al
 F5B5  03 C0			        add     ax, ax
 F5B7  EE			        out     dx, al
 F5B8  03 C0			        add     ax, ax
 F5BA  EE			        out     dx, al
 F5BB  03 C0			        add     ax, ax
 F5BD  EE			        out     dx, al
 F5BE  03 C0			        add     ax, ax
 F5C0  EE			        out     dx, al
 F5C1  03 C0			        add     ax, ax
 F5C3  EE			        out     dx, al
 F5C4  03 C0			        add     ax, ax
 F5C6  EE			        out     dx, al
 F5C7  03 C0			        add     ax, ax
 F5C9  EE			        out     dx, al
 F5CA  AC			        lodsb
 F5CB  EE			        out     dx, al
 F5CC  03 C0			        add     ax, ax
 F5CE  EE			        out     dx, al
 F5CF  03 C0			        add     ax, ax
 F5D1  EE			        out     dx, al
 F5D2  03 C0			        add     ax, ax
 F5D4  EE			        out     dx, al
 F5D5  03 C0			        add     ax, ax
 F5D7  EE			        out     dx, al
 F5D8  03 C0			        add     ax, ax
 F5DA  EE			        out     dx, al
 F5DB  03 C0			        add     ax, ax
 F5DD  EE			        out     dx, al
 F5DE  03 C0			        add     ax, ax
 F5E0  EE			        out     dx, al
 F5E1  E2 D0			        loop    short sdwblk1
 F5E3  C3			        ret
 F5E4				sdwblk endp

				;---------------------  read block ----------------------
 F5E4				sdrblk proc near              ; in DI=data ptr, DX=03dah, CX=size. Returns CF = 0
 F5E4  B0 FF			        mov     al, 0ffh
 F5E6  EE			        out     dx, al
 F5E7  D1 E9			        shr     cx, 1         ; CF = 0
 F5E9  EE			        out     dx, al
 F5EA  EB 05			        jmp     short sdrblk2 
 F5EC				sdrblk1:
 F5EC  EE			        out     dx, al
 F5ED  88 25			        mov     [di], ah
 F5EF  EE			        out     dx, al
 F5F0  47			        inc     di
 F5F1				sdrblk2:
 F5F1  EE			        out     dx, al
 F5F2  90			        nop
 F5F3  EE			        out     dx, al
 F5F4  90			        nop
 F5F5  EE			        out     dx, al
 F5F6  90			        nop
 F5F7  EE			        out     dx, al
 F5F8  90			        nop
 F5F9  EE			        out     dx, al
 F5FA  90			        nop
 F5FB  EE			        out     dx, al
 F5FC  ED			        in      ax, dx
 F5FD  EE			        out     dx, al
 F5FE  88 25			        mov     [di], ah
 F600  EE			        out     dx, al
 F601  47			        inc     di
 F602  EE			        out     dx, al
 F603  90			        nop
 F604  EE			        out     dx, al
 F605  90			        nop
 F606  EE			        out     dx, al
 F607  90			        nop
 F608  EE			        out     dx, al
 F609  90			        nop
 F60A  EE			        out     dx, al
 F60B  90			        nop
 F60C  EE			        out     dx, al
 F60D  ED			        in      ax, dx
 F60E  E2 DC			        loop    short sdrblk1
 F610  88 25			        mov     [di], ah
 F612  47			        inc     di
 F613  C3			        ret
 F614				sdrblk endp

				;---------------------  verify block ----------------------
 F614				sdvblk:              ; in DI=data ptr, DX=03dah, CX=size. Returns CF=1 on error
 F614  53			        push    bx
 F615  32 DB			        xor     bl, bl
 F617				sdvblk1:
 F617  E8 FF7D			        call    sdrb
 F61A  2A 25			        sub     ah, [di]
 F61C  0A DC			        or      bl, ah
 F61E  47			        inc     di
 F61F  E2 F6			        loop    short sdvblk1
 F621  F6 DB			        neg     bl  ; CF=1 if BL != 0
 F623  5B			        pop     bx
 F624  C3			        ret

				;---------------------  write command ----------------------
 F625				sdcmd8T:
 F625  E8 FF6F			        call    sdrb
 F628				sdcmd:              ; in SI=6 bytes cmd buffer, DX=03dah, out AH = 0ffh on error
 F628  B9 0006			        mov     cx, 6
 F62B  E8 FF83			        call    sdwblk
 F62E				sdresp:
 F62E  33 F6			        xor     si, si
 F630				sdresp1:
 F630  E8 FF64			        call    sdrb
 F633  46			        inc     si
 F634  74 05			        jz      short sdcmd1
 F636  80 FC FF			        cmp     ah, 0ffh
 F639  74 F5			        je      short sdresp1
 F63B  C3			sdcmd1: ret         

				;---------------------  read ----------------------
 F63C				sdverify:
 F63C  68 F614 R		        push    sdvblk
 F63F  EB 03			        jmp     short sdread1
 F641				sdread:   ; DX:AX sector, ES:BX buffer, CX=sectors. returns AX=read sectors
 F641  68 F5E4 R		        push    sdrblk   ; push proc address (read or verify) on stack
 F644				sdread1:        
 F644  50			        push    ax
 F645  8A C2			        mov     al, dl
 F647  50			        push    ax
 F648  B2 51			        mov     dl, 51h  ; CMD17
 F64A  83 F9 01			        cmp     cx, 1
 F64D  74 01			        je      short sdr1s
 F64F  42			        inc     dx      ; CMD18 - multiple sectors
 F650				sdr1s:
 F650  52			        push    dx
 F651  8B F4			        mov     si, sp 

 F653  BA 03DA			        mov     dx, 3dah
 F656  B4 01			        mov     ah, 1
 F658  EF			        out     dx, ax       ; CS on
 F659  8B FB			        mov     di, bx
 F65B  8B D9			        mov     bx, cx
 F65D  8B E9			        mov     bp, cx       ; save sectors number
 F65F  16			        push    ss
 F660  1F			        pop     ds
 F661  C6 44 05 FF			mov	byte ptr [si+5], 0ffh ; checksum
 F665  E8 FFC0			        call    sdcmd
 F668  83 C4 06			        add     sp, 6
 F66B  0A E4			        or      ah, ah
 F66D  75 41			        jnz     short sdr11   ; error
 F66F  06			        push    es
 F670  1F			        pop     ds
 F671				sdrms:
 F671  8B C7			        mov     ax, di
 F673  C1 E8 04			        shr     ax, 4
 F676  8C DE			        mov     si, ds
 F678  03 C6			        add     ax, si
 F67A  8E D8			        mov     ds, ax
 F67C  83 E7 0F			        and     di, 15
 F67F  E8 FFAC			        call    sdresp     ; wait for 0feh token
 F682  80 FC FE			        cmp     ah, 0feh
 F685  75 29			        jne     short sdr11; read token error 
 F687  B5 02			        mov     ch, 2      ; 512 byte sector
 F689  5E			        pop     si
 F68A  FF D6			        call    si         ; sdrblk or sdvblk
 F68C  56			        push    si
 F68D  9C			        pushf
 F68E  E8 FF06			        call    sdrb       ; ignore CRC
 F691  E8 FF03			        call    sdrb       ; ignore CRC
 F694  9D			        popf
 F695  72 03			        jc      short sdr3 ; verify error   
 F697  4B			        dec     bx
 F698  75 D7			        jnz     short sdrms; multiple sectors
 F69A				sdr3:        
 F69A  83 FD 01			        cmp     bp, 1
 F69D  74 11			        je      short sdr11; single sector
 F69F  BE F7E9 R		        mov     si, offset SD_CMD12 ; stop transfer
 F6A2  0E			        push    cs
 F6A3  1F			        pop     ds
 F6A4  E8 FF81			        call    sdcmd
 F6A7				sdr2:
 F6A7  D0 EC			        shr     ah, 1
 F6A9  73 05			        jnc     short sdr11
 F6AB  E8 FEE9			        call    sdrb
 F6AE  EB F7			        jmp     short sdr2
 F6B0				sdr11:
 F6B0  58			        pop     ax         ; remove proc address from stack
 F6B1				sdr1:       
 F6B1  33 C0			        xor     ax, ax
 F6B3  EF			        out     dx, ax
 F6B4  E8 FEE0			        call    sdrb       ; 8T
 F6B7  8B C5			        mov     ax, bp
 F6B9  2B C3			        sub     ax, bx
 F6BB  C3			        ret     

				;---------------------  write ----------------------
 F6BC				sdwrite:   ; DX:AX sector, ES:BX buffer, CX=sectors, returns AX=wrote sectors
 F6BC  50			        push    ax
 F6BD  8A C2			        mov     al, dl
 F6BF  50			        push    ax
 F6C0  B2 58			        mov     dl, 58h  ; CMD24
 F6C2  83 F9 01			        cmp     cx, 1
 F6C5  74 01			        je      short sdw1s
 F6C7  42			        inc     dx      ; CMD25 - multiple sectors
 F6C8				sdw1s:
 F6C8  52			        push    dx
 F6C9  8B F4			        mov     si, sp 

 F6CB  BA 03DA			        mov     dx, 3dah
 F6CE  B4 01			        mov     ah, 1
 F6D0  EF			        out     dx, ax       ; CS on
 F6D1  8B E9			        mov     bp, cx       ; save sectors number
 F6D3  16			        push    ss
 F6D4  1F			        pop     ds
 F6D5  C6 44 05 FF			mov	byte ptr [si+5], 0ffh ; checksum
 F6D9  E8 FF4C			        call    sdcmd
 F6DC  83 C4 06			        add     sp, 6
 F6DF  8B F3			        mov     si, bx
 F6E1  8B DD			        mov     bx, bp
 F6E3  0A E4			        or      ah, ah
 F6E5  75 CA			        jnz     short sdr1   ; error
 F6E7  06			        push    es
 F6E8  1F			        pop     ds
 F6E9				sdwms:
 F6E9  8B C6			        mov     ax, si
 F6EB  C1 E8 04			        shr     ax, 4
 F6EE  8C DF			        mov     di, ds
 F6F0  03 C7			        add     ax, di
 F6F2  8E D8			        mov     ds, ax
 F6F4  83 E6 0F			        and     si, 15
 F6F7  B0 FE			        mov     al, 0feh      ; start token
 F6F9  83 FD 01			        cmp     bp, 1
 F6FC  74 02			        je      short sdw1s1
 F6FE  B0 FC			        mov     al, 0fch   ; multiple sectors
 F700				sdw1s1:        
 F700  E8 FE96			        call    sdsb     
 F703  B5 02			        mov     ch, 2      ; 512 byte sector
 F705  E8 FEA9			        call    sdwblk
 F708  E8 FE8C			        call    sdrb       ; ignore CRC
 F70B  E8 FE89			        call    sdrb       ; ignore CRC
 F70E  E8 FE86			        call    sdrb       ; read response byte xxx00101
 F711  80 E4 0E			        and     ah, 0eh
 F714  80 FC 04			        cmp     ah, 4
 F717  75 98			        jne     short sdr1 ; write error
 F719				sdwwait:
 F719  E8 FE7B			        call    sdrb
 F71C  D0 EC			        shr     ah, 1
 F71E  73 F9			        jnc     short sdwwait     ; wait write completion
 F720  4B			        dec     bx
 F721  75 C6			        jnz     short sdwms       ; multiple sectors

 F723  83 FD 01			        cmp     bp, 1
 F726  74 89			        je      short sdr1
 F728  B0 FD			        mov     al, 0fdh     ; multiple end transfer
 F72A  E8 FE6C			        call    sdsb 
 F72D  E8 FE67					call	sdrb     
 F730				sdwwait1:
 F730  E8 FE64			        call    sdrb
 F733  D0 EC			        shr     ah, 1
 F735  73 F9			        jnc     short sdwwait1     ; wait write completion
 F737  E9 FF77			        jmp     sdr1
				        
				;---------------------  init SD ----------------------
 F73A				sdinit  proc near       ; returns AX = num kilosectors
 F73A  1E			        push    ds
 F73B  51			        push    cx
 F73C  52			        push    dx
 F73D  56			        push    si
 F73E  57			        push    di
 F73F  BA 03DA			        mov     dx, 3dah
 F742  B9 000A			        mov     cx, 10
 F745				sdinit1:                   ; send 80T
 F745  E8 FE4F			        call    sdrb
 F748  E2 FB			        loop    short sdinit1

 F74A  B4 01			        mov     ah, 1
 F74C  EF			        out     dx, ax       ; select SD

 F74D  BE F7D7 R		        mov     si, offset SD_CMD0
 F750  0E			        push    cs
 F751  1F			        pop     ds
 F752  E8 FED3			        call    sdcmd
 F755  FE CC			        dec     ah
 F757  75 70			        jnz     short sdexit ; error
				        
 F759  BE F7DD R		        mov     si, offset SD_CMD8
 F75C  E8 FEC6			        call    sdcmd8T
 F75F  FE CC			        dec     ah
 F761  75 66			        jnz     short sdexit ; error
 F763  B1 04			        mov     cl, 4
 F765  2B E1			        sub     sp, cx
 F767  8B FC			        mov     di, sp
 F769  16			        push    ss
 F76A  1F			        pop     ds
 F76B  E8 FE76			        call    sdrblk
 F76E  58			        pop     ax
 F76F  58			        pop     ax
 F770  80 FC AA			        cmp     ah, 0aah
 F773  75 54			        jne     short sdexit ; CMD8 error
 F775				repinit:        
 F775  BE F7F5 R		        mov     si, offset SD_CMD55
 F778  0E			        push    cs
 F779  1F			        pop     ds
 F77A  E8 FEA8			        call    sdcmd8T
 F77D  E8 FE17			        call    sdrb
 F780  BE F7EF R		        mov     si, offset SD_CMD41
 F783  E8 FEA2			        call    sdcmd
 F786  FE CC			        dec     ah
 F788  74 EB			        jz      short repinit
				        
 F78A  BE F7FB R		        mov     si, offset SD_CMD58
 F78D  E8 FE95			        call    sdcmd8T
 F790  B1 04			        mov     cl, 4
 F792  2B E1			        sub     sp, cx
 F794  8B FC			        mov     di, sp
 F796  16			        push    ss
 F797  1F			        pop     ds
 F798  E8 FE49			        call    sdrblk
 F79B  58			        pop     ax
 F79C  A8 40			        test    al, 40h     ; test OCR bit 30 (CCS)
 F79E  58			        pop     ax
 F79F  74 28			        jz      short sdexit; no SDHC

 F7A1  BE F7E3 R		        mov     si, offset SD_CMD9 ; get size info
 F7A4  0E			        push    cs
 F7A5  1F			        pop     ds
 F7A6  E8 FE7C			        call    sdcmd8T
 F7A9  0A E4			        or      ah, ah
 F7AB  75 1C			        jnz     short sdexit
 F7AD  E8 FE7E			        call    sdresp     ; wait for 0feh token
 F7B0  80 FC FE			        cmp     ah, 0feh
 F7B3  75 14			        jne     short sdexit
 F7B5  B1 12			        mov     cl, 18       ; 16bytes + 2bytes CRC
 F7B7  2B E1			        sub     sp, cx
 F7B9  8B FC			        mov     di, sp
 F7BB  16			        push    ss
 F7BC  1F			        pop     ds
 F7BD  E8 FE24			        call    sdrblk
 F7C0  8B 4D F6			        mov     cx, [di-10]
 F7C3  C1 C1 08			        rol     cx, 8
 F7C6  41			        inc     cx
 F7C7  8B E7			        mov     sp, di
 F7C9				sdexit: 
 F7C9  33 C0			        xor     ax, ax       ; raise CS
 F7CB  EF			        out     dx, ax
 F7CC  E8 FDC8			        call    sdrb
 F7CF  5F			        pop     di
 F7D0  5E			        pop     si
 F7D1  5A			        pop     dx
 F7D2  8B C1			        mov     ax, cx       
 F7D4  59			        pop     cx
 F7D5  1F			        pop     ds
 F7D6  C3			        ret
 F7D7				sdinit endp
				    
 F7D7 40 00 00 00 00 95		SD_CMD0     db  40h, 0, 0, 0, 0, 95h
 F7DD 48 00 00 01 AA 87		SD_CMD8     db  48h, 0, 0, 1, 0aah, 087h
 F7E3 49 00 00 00 00 FF		SD_CMD9     db  49h, 0, 0, 0, 0, 0ffh
 F7E9 4C 00 00 00 00 FF		SD_CMD12    db  4ch, 0, 0, 0, 0, 0ffh
 F7EF 69 40 00 00 00 FF		SD_CMD41    db  69h, 40h, 0, 0, 0, 0ffh
 F7F5 77 00 00 00 00 FF		SD_CMD55    db  77h, 0, 0, 0, 0, 0ffh
 F7FB 7A 00 00 00 00 FF		SD_CMD58    db  7ah, 0, 0, 0, 0, 0ffh


 F801				default_pal:
 F801  00 00 00 00 00 2A	        db  00h,00h,00h, 00h,00h,2ah, 00h,2ah,00h, 00h,2ah,2ah, 2ah,00h,00h, 2ah,00h,2ah, 2ah,15h,00h, 2ah,2ah,2ah 
       00 2A 00 00 2A 2A
       2A 00 00 2A 00 2A
       2A 15 00 2A 2A 2A
 F819  15 15 15 15 15 3F	        db  15h,15h,15h, 15h,15h,3fh, 15h,3fh,15h, 15h,3fh,3fh, 3fh,15h,15h, 3fh,15h,3fh, 3fh,3fh,15h, 3fh,3fh,3fh 
       15 3F 15 15 3F 3F
       3F 15 15 3F 15 3F
       3F 3F 15 3F 3F 3F
 F831  00 00 00 05 05 05	        db  00h,00h,00h, 05h,05h,05h, 08h,08h,08h, 0bh,0bh,0bh, 0eh,0eh,0eh, 11h,11h,11h, 14h,14h,14h, 18h,18h,18h 
       08 08 08 0B 0B 0B
       0E 0E 0E 11 11 11
       14 14 14 18 18 18
 F849  1C 1C 1C 20 20 20	        db  1ch,1ch,1ch, 20h,20h,20h, 24h,24h,24h, 28h,28h,28h, 2dh,2dh,2dh, 32h,32h,32h, 38h,38h,38h, 3fh,3fh,3fh 
       24 24 24 28 28 28
       2D 2D 2D 32 32 32
       38 38 38 3F 3F 3F
 F861  00 00 3F 10 00 3F	        db  00h,00h,3fh, 10h,00h,3fh, 1fh,00h,3fh, 2fh,00h,3fh, 3fh,00h,3fh, 3fh,00h,2fh, 3fh,00h,1fh, 3fh,00h,10h 
       1F 00 3F 2F 00 3F
       3F 00 3F 3F 00 2F
       3F 00 1F 3F 00 10
 F879  3F 00 00 3F 10 00	        db  3fh,00h,00h, 3fh,10h,00h, 3fh,1fh,00h, 3fh,2fh,00h, 3fh,3fh,00h, 2fh,3fh,00h, 1fh,3fh,00h, 10h,3fh,00h 
       3F 1F 00 3F 2F 00
       3F 3F 00 2F 3F 00
       1F 3F 00 10 3F 00
 F891  00 3F 00 00 3F 10	        db  00h,3fh,00h, 00h,3fh,10h, 00h,3fh,1fh, 00h,3fh,2fh, 00h,3fh,3fh, 00h,2fh,3fh, 00h,1fh,3fh, 00h,10h,3fh 
       00 3F 1F 00 3F 2F
       00 3F 3F 00 2F 3F
       00 1F 3F 00 10 3F
 F8A9  1F 1F 3F 27 1F 3F	        db  1fh,1fh,3fh, 27h,1fh,3fh, 2fh,1fh,3fh, 37h,1fh,3fh, 3fh,1fh,3fh, 3fh,1fh,37h, 3fh,1fh,2fh, 3fh,1fh,27h 
       2F 1F 3F 37 1F 3F
       3F 1F 3F 3F 1F 37
       3F 1F 2F 3F 1F 27
 F8C1  3F 1F 1F 3F 27 1F	        db  3fh,1fh,1fh, 3fh,27h,1fh, 3fh,2fh,1fh, 3fh,37h,1fh, 3fh,3fh,1fh, 37h,3fh,1fh, 2fh,3fh,1fh, 27h,3fh,1fh 
       3F 2F 1F 3F 37 1F
       3F 3F 1F 37 3F 1F
       2F 3F 1F 27 3F 1F
 F8D9  1F 3F 1F 1F 3F 27	        db  1fh,3fh,1fh, 1fh,3fh,27h, 1fh,3fh,2fh, 1fh,3fh,37h, 1fh,3fh,3fh, 1fh,37h,3fh, 1fh,2fh,3fh, 1fh,27h,3fh 
       1F 3F 2F 1F 3F 37
       1F 3F 3F 1F 37 3F
       1F 2F 3F 1F 27 3F
 F8F1  2D 2D 3F 31 2D 3F	        db  2dh,2dh,3fh, 31h,2dh,3fh, 36h,2dh,3fh, 3ah,2dh,3fh, 3fh,2dh,3fh, 3fh,2dh,3ah, 3fh,2dh,36h, 3fh,2dh,31h 
       36 2D 3F 3A 2D 3F
       3F 2D 3F 3F 2D 3A
       3F 2D 36 3F 2D 31
 F909  3F 2D 2D 3F 31 2D	        db  3fh,2dh,2dh, 3fh,31h,2dh, 3fh,36h,2dh, 3fh,3ah,2dh, 3fh,3fh,2dh, 3ah,3fh,2dh, 36h,3fh,2dh, 31h,3fh,2dh 
       3F 36 2D 3F 3A 2D
       3F 3F 2D 3A 3F 2D
       36 3F 2D 31 3F 2D
 F921  2D 3F 2D 2D 3F 31	        db  2dh,3fh,2dh, 2dh,3fh,31h, 2dh,3fh,36h, 2dh,3fh,3ah, 2dh,3fh,3fh, 2dh,3ah,3fh, 2dh,36h,3fh, 2dh,31h,3fh 
       2D 3F 36 2D 3F 3A
       2D 3F 3F 2D 3A 3F
       2D 36 3F 2D 31 3F
 F939  00 00 1C 07 00 1C	        db  00h,00h,1ch, 07h,00h,1ch, 0eh,00h,1ch, 15h,00h,1ch, 1ch,00h,1ch, 1ch,00h,15h, 1ch,00h,0eh, 1ch,00h,07h 
       0E 00 1C 15 00 1C
       1C 00 1C 1C 00 15
       1C 00 0E 1C 00 07
 F951  1C 00 00 1C 07 00	        db  1ch,00h,00h, 1ch,07h,00h, 1ch,0eh,00h, 1ch,15h,00h, 1ch,1ch,00h, 15h,1ch,00h, 0eh,1ch,00h, 07h,1ch,00h 
       1C 0E 00 1C 15 00
       1C 1C 00 15 1C 00
       0E 1C 00 07 1C 00
 F969  00 1C 00 00 1C 07	        db  00h,1ch,00h, 00h,1ch,07h, 00h,1ch,0eh, 00h,1ch,15h, 00h,1ch,1ch, 00h,15h,1ch, 00h,0eh,1ch, 00h,07h,1ch 
       00 1C 0E 00 1C 15
       00 1C 1C 00 15 1C
       00 0E 1C 00 07 1C
 F981  0E 0E 1C 11 0E 1C	        db  0eh,0eh,1ch, 11h,0eh,1ch, 15h,0eh,1ch, 18h,0eh,1ch, 1ch,0eh,1ch, 1ch,0eh,18h, 1ch,0eh,15h, 1ch,0eh,11h 
       15 0E 1C 18 0E 1C
       1C 0E 1C 1C 0E 18
       1C 0E 15 1C 0E 11
 F999  1C 0E 0E 1C 11 0E	        db  1ch,0eh,0eh, 1ch,11h,0eh, 1ch,15h,0eh, 1ch,18h,0eh, 1ch,1ch,0eh, 18h,1ch,0eh, 15h,1ch,0eh, 11h,1ch,0eh 
       1C 15 0E 1C 18 0E
       1C 1C 0E 18 1C 0E
       15 1C 0E 11 1C 0E
 F9B1  0E 1C 0E 0E 1C 11	        db  0eh,1ch,0eh, 0eh,1ch,11h, 0eh,1ch,15h, 0eh,1ch,18h, 0eh,1ch,1ch, 0eh,18h,1ch, 0eh,15h,1ch, 0eh,11h,1ch 
       0E 1C 15 0E 1C 18
       0E 1C 1C 0E 18 1C
       0E 15 1C 0E 11 1C
 F9C9  14 14 1C 16 14 1C	        db  14h,14h,1ch, 16h,14h,1ch, 18h,14h,1ch, 1ah,14h,1ch, 1ch,14h,1ch, 1ch,14h,1ah, 1ch,14h,18h, 1ch,14h,16h 
       18 14 1C 1A 14 1C
       1C 14 1C 1C 14 1A
       1C 14 18 1C 14 16
 F9E1  1C 14 14 1C 16 14	        db  1ch,14h,14h, 1ch,16h,14h, 1ch,18h,14h, 1ch,1ah,14h, 1ch,1ch,14h, 1ah,1ch,14h, 18h,1ch,14h, 16h,1ch,14h 
       1C 18 14 1C 1A 14
       1C 1C 14 1A 1C 14
       18 1C 14 16 1C 14
 F9F9  14 1C 14 14 1C 16	        db  14h,1ch,14h, 14h,1ch,16h, 14h,1ch,18h, 14h,1ch,1ah, 14h,1ch,1ch, 14h,1ah,1ch, 14h,18h,1ch, 14h,16h,1ch 
       14 1C 18 14 1C 1A
       14 1C 1C 14 1A 1C
       14 18 1C 14 16 1C
 FA11  00 00 10 04 00 10	        db  00h,00h,10h, 04h,00h,10h, 08h,00h,10h, 0ch,00h,10h, 10h,00h,10h, 10h,00h,0ch, 10h,00h,08h, 10h,00h,04h 
       08 00 10 0C 00 10
       10 00 10 10 00 0C
       10 00 08 10 00 04
 FA29  10 00 00 10 04 00	        db  10h,00h,00h, 10h,04h,00h, 10h,08h,00h, 10h,0ch,00h, 10h,10h,00h, 0ch,10h,00h, 08h,10h,00h, 04h,10h,00h 
       10 08 00 10 0C 00
       10 10 00 0C 10 00
       08 10 00 04 10 00
 FA41  00 10 00 00 10 04	        db  00h,10h,00h, 00h,10h,04h, 00h,10h,08h, 00h,10h,0ch, 00h,10h,10h, 00h,0ch,10h, 00h,08h,10h, 00h,04h,10h 
       00 10 08 00 10 0C
       00 10 10 00 0C 10
       00 08 10 00 04 10
 FA59  08 08 10 0A 08 10	        db  08h,08h,10h, 0ah,08h,10h, 0ch,08h,10h, 0eh,08h,10h, 10h,08h,10h, 10h,08h,0eh, 10h,08h,0ch, 10h,08h,0ah 
       0C 08 10 0E 08 10
       10 08 10 10 08 0E
       10 08 0C 10 08 0A
 FA71  10 08 08 10 0A 08	        db  10h,08h,08h, 10h,0ah,08h, 10h,0ch,08h, 10h,0eh,08h, 10h,10h,08h, 0eh,10h,08h, 0ch,10h,08h, 0ah,10h,08h 
       10 0C 08 10 0E 08
       10 10 08 0E 10 08
       0C 10 08 0A 10 08
 FA89  08 10 08 08 10 0A	        db  08h,10h,08h, 08h,10h,0ah, 08h,10h,0ch, 08h,10h,0eh, 08h,10h,10h, 08h,0eh,10h, 08h,0ch,10h, 08h,0ah,10h 
       08 10 0C 08 10 0E
       08 10 10 08 0E 10
       08 0C 10 08 0A 10
 FAA1  0B 0B 10 0C 0B 10	        db  0bh,0bh,10h, 0ch,0bh,10h, 0dh,0bh,10h, 0fh,0bh,10h, 10h,0bh,10h, 10h,0bh,0fh, 10h,0bh,0dh, 10h,0bh,0ch 
       0D 0B 10 0F 0B 10
       10 0B 10 10 0B 0F
       10 0B 0D 10 0B 0C
 FAB9  10 0B 0B 10 0C 0B	        db  10h,0bh,0bh, 10h,0ch,0bh, 10h,0dh,0bh, 10h,0fh,0bh, 10h,10h,0bh, 0fh,10h,0bh, 0dh,10h,0bh, 0ch,10h,0bh 
       10 0D 0B 10 0F 0B
       10 10 0B 0F 10 0B
       0D 10 0B 0C 10 0B
 FAD1  0B 10 0B 0B 10 0C	        db  0bh,10h,0bh, 0bh,10h,0ch, 0bh,10h,0dh, 0bh,10h,0fh, 0bh,10h,10h, 0bh,0fh,10h, 0bh,0dh,10h, 0bh,0ch,10h 
       0B 10 0D 0B 10 0F
       0B 10 10 0B 0F 10
       0B 0D 10 0B 0C 10
 FAE9  00 00 00 00 00 00	        db  00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h, 00h,00h,00h
       00 00 00 00 00 00
       00 00 00 00 00 00
       00 00 00 00 00 00

				IFDEF SCANCODE1 ; use SCANCODE1
 FB01				KeyIndex:
 FB01  00 52 31 32 34 33	        db	0, 82, 49, 50, 52, 51, 54, 55    ;0-7
       36 37
 FB09  38 39 3C 3B 41 44	        db 56, 57, 60, 59, 65, 68, 72, 47    ;8-f
       48 2F
 FB11  01 05 09 0D 0C 12	        db	1,  5,  9, 13, 12, 18, 21, 23    ;10-17
       15 17
 FB19  18 1A 43 46 45 00	        db 24, 26, 67, 70, 69,  0,  4,  3    ;18-1f
       04 03
 FB21  08 0B 11 10 14 16	        db	8, 11, 17, 16, 20, 22, 25, 64    ;20-27
       19 40
 FB29  42 30 00 47 02 07	        db 66, 48,  0, 71,  2,  7,  6, 10    ;28-2f
       06 0A
 FB31  0F 0E 13 3A 3D 3E	        db 15, 14, 19, 58, 61, 62,  0, 87    ;30-37
       00 57
 FB39  00 35 00 28 29 27	        db	0, 53,  0, 40, 41, 39, 46, 38    ;38-3f
       2E 26
 FB41  2D 5A 2C 4F 2B 00	        db 45, 90, 44, 79, 43,  0, 89, 29    ;40-47
       59 1D
 FB49  22 24 56 1C 25 21	        db 34, 36, 86, 28, 37, 33, 84, 27    ;48-4f
       54 1B
 FB51  20 23 1E 1F 00 00	        db 32, 35, 30, 31,  0,  0,	0, 83    ;50-57  
       00 53
 FB59  2A			        db 42
 FB5A				E0KeyList:
 FB5A  35 1C 4F 4B 47 52		db	35h, 1ch, 4fh, 4bh, 47h, 52h, 53h, 50h, 4dh, 48h, 51h, 49h 
       53 50 4D 48 51 49

				ELSE    ; use SCANCODE2
				ENDIF

 FB66				E0KeyIndex:
 FB66  3F 45 49 4A 4B 4C		db	63,  69,  73,  74,  75,  76,  77,  78,  80,  81,  85,  88
       4D 4E 50 51 55 58

 FB72				KeyCode:	  
				; Keys affected by CapsLock
				;		norm   shft   ctrl   alt
 FB72  0000 0000 0000		        dw	0000h, 0000h, 0000h, 0000h ;17 - <0>
       0000
 FB7A  1071 1051 1011		        dw	1071h, 1051h, 1011h, 1000h ;15 - Q, (E0)PrevTrack <1>
       1000
 FB82  2C7A 2C5A 2C1A		        dw	2c7ah, 2c5ah, 2c1ah, 2c00h ;1a - Z <2>
       2C00
 FB8A  1F73 1F53 1F13		        dw	1f73h, 1f53h, 1f13h, 1f00h ;1b - S <3>
       1F00
 FB92  1E61 1E41 1E01		        dw	1e61h, 1e41h, 1e01h, 1e00h ;1c - A <4>
       1E00
 FB9A  1177 1157 1117		        dw	1177h, 1157h, 1117h, 1100h ;1d - W <5>
       1100
 FBA2  2E63 2E43 2E03		        dw	2e63h, 2e43h, 2e03h, 2e00h ;21 - C, (E0)Volume Down <6>
       2E00
 FBAA  2D78 2D58 2D18		        dw	2d78h, 2d58h, 2d18h, 2d00h ;22 - X <7>
       2D00
 FBB2  2064 2044 2004		        dw	2064h, 2044h, 2004h, 2000h ;23 - D, (E0)Mute <8>
       2000
 FBBA  1265 1245 1205		        dw	1265h, 1245h, 1205h, 1200h ;24 - E <9>
       1200
 FBC2  2F76 2F56 2F16		        dw	2f76h, 2f56h, 2f16h, 2f00h ;2a - V <10>
       2F00
 FBCA  2166 2146 2106		        dw	2166h, 2146h, 2106h, 2100h ;2b - F, (E0)Calculator <11>
       2100
 FBD2  1474 1454 1414		        dw	1474h, 1454h, 1414h, 1400h ;2c - T <12>
       1400
 FBDA  1372 1352 1312		        dw	1372h, 1352h, 1312h, 1300h ;2d - R <13>
       1300
 FBE2  316E 314E 310E		        dw	316eh, 314eh, 310eh, 3100h ;31 - N <14>
       3100
 FBEA  3062 3042 3002		        dw	3062h, 3042h, 3002h, 3000h ;32 - B, (E0)Volume Up <15>
       3000
 FBF2  2368 2348 2308		        dw	2368h, 2348h, 2308h, 2300h ;33 - H <16>
       2300
 FBFA  2267 2247 2207		        dw	2267h, 2247h, 2207h, 2200h ;34 - G, (E0)Play/Pause <17>
       2200
 FC02  1579 1559 1519		        dw	1579h, 1559h, 1519h, 1500h ;35 - Y <18>
       1500
 FC0A  326D 324D 320D		        dw	326dh, 324dh, 320dh, 3200h ;3a - M, (E0)WWW Home <19>
       3200
 FC12  246A 244A 240A		        dw	246ah, 244ah, 240ah, 2400h ;3b - J, (E0)Stop <20>
       2400
 FC1A  1675 1655 1615		        dw	1675h, 1655h, 1615h, 1600h ;3c - U <21>
       1600
 FC22  256B 254B 250B		        dw	256bh, 254bh, 250bh, 2500h ;42 - K <22>
       2500
 FC2A  1769 1749 1709		        dw	1769h, 1749h, 1709h, 1700h ;43 - I <23>
       1700
 FC32  186F 184F 180F		        dw	186fh, 184fh, 180fh, 1800h ;44 - O <24>
       1800
 FC3A  266C 264C 260C		        dw	266ch, 264ch, 260ch, 2600h ;4b - L <25>
       2600
 FC42  1970 1950 1910		        dw	1970h, 1950h, 1910h, 1900h ;4d - P, (E0)Next Track <26>
       1900
				; keys affected by NumLock	
 FC4A  4F00 4F31 7500		        dw	4f00h, 4f31h, 7500h, 0002h ;69 - KP1 <27>
       0002
 FC52  4B00 4B34 7300		        dw	4b00h, 4b34h, 7300h, 0005h ;6b - KP4 <28>
       0005
 FC5A  4700 4737 7700		        dw	4700h, 4737h, 7700h, 0008h ;6c - KP7 <29>
       0008
 FC62  5200 5230 9200		        dw	5200h, 5230h, 9200h, 0001h ;70 - KP0 <30>
       0001
 FC6A  5300 532E 9300		        dw	5300h, 532eh, 9300h, 0000h ;71 - KP. <31>
       0000
 FC72  5000 5032 9100		        dw	5000h, 5032h, 9100h, 0003h ;72 - KP2 <32>
       0003
 FC7A  4D00 4D36 7400		        dw	4d00h, 4d36h, 7400h, 0007h ;74 - KP6 <33>
       0007
 FC82  4800 4838 8D00		        dw	4800h, 4838h, 8d00h, 0009h ;75 - KP8 <34>
       0009
 FC8A  5100 5133 7600		        dw	5100h, 5133h, 7600h, 0004h ;7a - KP3 <35>
       0004
 FC92  4900 4939 8400		        dw	4900h, 4939h, 8400h, 000ah ;7d - KP9 <36>
       000A
 FC9A  4C00 4C35 8F00		        dw	4c00h, 4c35h, 8f00h, 0006h ;73 - KP5 --- on VMWare, it does not send 4c00 <37>
       0006
				; keys unaffected by CapsLock or N
 FCA2  3F00 5800 6200		        dw	3f00h, 5800h, 6200h, 6c00h ;03 - F5 <38>
       6C00
 FCAA  3D00 5600 6000		        dw	3d00h, 5600h, 6000h, 6a00h ;04 - F3 <39>
       6A00
 FCB2  3B00 5400 5E00		        dw	3b00h, 5400h, 5e00h, 6800h ;05 - F1 <40>
       6800
 FCBA  3C00 5500 5F00		        dw	3c00h, 5500h, 5f00h, 6900h ;06 - F2 <41>
       6900
 FCC2  8600 8800 8A00		        dw	8600h, 8800h, 8a00h, 8c00h ;07 - F12 <42>	
       8C00
 FCCA  4400 5D00 6700		        dw	4400h, 5d00h, 6700h, 7100h ;09 - F10 <43>
       7100
 FCD2  4200 5B00 6500		        dw	4200h, 5b00h, 6500h, 6f00h ;0a - F8 <44>
       6F00
 FCDA  4000 5900 6300		        dw	4000h, 5900h, 6300h, 6d00h ;0b - F6 <45>
       6D00
 FCE2  3E00 5700 6100		        dw	3e00h, 5700h, 6100h, 6b00h ;0c - F4 <46>
       6B00
 FCEA  0F09 0F00 9400		        dw	0f09h, 0f00h, 9400h, 0000h ;0d - TAB <47>	
       0000
 FCF2  2960 297E 0000		        dw	2960h, 297eh, 0000h, 2900h ;0e - ` ~ <48>	
       2900
 FCFA  0231 0221 0000		        dw	0231h, 0221h, 0000h, 7800h ;16 - 1 ! <49>	
       7800
 FD02  0332 0340 0300		        dw	0332h, 0340h, 0300h, 7900h ;1e - 2 @ <50>	
       7900
 FD0A  0534 0524 0000		        dw	0534h, 0524h, 0000h, 7b00h ;25 - 4 $ <51>
       7B00
 FD12  0433 0423 0000		        dw	0433h, 0423h, 0000h, 7a00h ;26 - 3 # <52>
       7A00
 FD1A  3920 3920 3920		        dw	3920h, 3920h, 3920h, 3920h ;29 - SPC <53>	
       3920
 FD22  0635 0625 0000		        dw	0635h, 0625h, 0000h, 7c00h ;2e - 5 % <54>
       7C00
 FD2A  0736 075E 071E		        dw	0736h, 075eh, 071eh, 7d00h ;36 - 6 ^ <55>
       7D00
 FD32  0837 0826 0000		        dw	0837h, 0826h, 0000h, 7e00h ;3d - 7 & <56>
       7E00
 FD3A  0938 092A 0000		        dw	0938h, 092ah, 0000h, 7f00h ;3e - 8 * <57>
       7F00
 FD42  332C 333C 0000		        dw	332ch, 333ch, 0000h, 3300h ;41 - , < <58>
       3300
 FD4A  0B30 0B29 0000		        dw	0b30h, 0b29h, 0000h, 8100h ;45 - 0 ) <59>
       8100
 FD52  0A39 0A28 0000		        dw	0a39h, 0a28h, 0000h, 8000h ;46 - 9 ( <60>
       8000
 FD5A  342E 343E 0000		        dw	342eh, 343eh, 0000h, 3400h ;49 - . > <61>
       3400
 FD62  352F 353F 0000		        dw	352fh, 353fh, 0000h, 3500h ;4a - / ? <62>
       3500
 FD6A  E02F E02F 9500		        dw	0e02fh, 0e02fh, 9500h, 0a400h ;4a - (e0)KP/ <63>
       A400
 FD72  273B 273A 0000		        dw	273bh, 273ah, 0000h, 2700h ;4c - ; : <64>
       2700
 FD7A  0C2D 0C5F 0C1F		        dw	0c2dh, 0c5fh, 0c1fh, 8200h ;4e - - _ <65>
       8200
 FD82  2827 2822 0000		        dw	2827h, 2822h, 0000h, 2800h ;52 -   <66>
       2800
 FD8A  1A5B 1A7B 1A1B		        dw	1a5bh, 1a7bh, 1a1bh, 1a00h ;54 - [ { <67>
       1A00
 FD92  0D3D 0D2B 0000		        dw	0d3dh, 0d2bh, 0000h, 8300h ;55 - = + <68>	
       8300
 FD9A  1C0D 1C0D 1C0A		        dw	1c0dh, 1c0dh, 1c0ah, 1c00h ;5a - Enter, (E0)KPEnter <69>
       1C00
 FDA2  1B5D 1B7D 1B1D		        dw	1b5dh, 1b7dh, 1b1dh, 1b00h ;5b - ] } <70>
       1B00
 FDAA  2B5C 2B7C 2B1C		        dw	2b5ch, 2b7ch, 2b1ch, 2b00h ;5d - \ | <71>
       2B00
 FDB2  0E08 0E08 0E7F		        dw	0e08h, 0e08h, 0e7fh, 0e00h ;66 - BKSP <72>
       0E00
 FDBA  4F00 4F00 7500		        dw	4f00h, 4f00h, 7500h, 9f00h ;69 - (E0)END <73>
       9F00
 FDC2  4B00 4B00 7300		        dw	4b00h, 4b00h, 7300h, 9b00h ;6b - (E0)LEFT <74>
       9B00
 FDCA  4700 4700 7700		        dw	4700h, 4700h, 7700h, 9700h ;6c - (E0)HOME <75>
       9700
 FDD2  5200 5200 9200		        dw	5200h, 5200h, 9200h, 0a200h ;70 - (E0)INS <76>
       A200
 FDDA  5300 5300 9300		        dw	5300h, 5300h, 9300h, 0a300h ;71 - (E0)DEL <77>
       A300
 FDE2  5000 5000 9100		        dw	5000h, 5000h, 9100h, 0a000h ;72 - (E0)DOWN <78>
       A000
 FDEA  4300 5C00 6600		        dw	4300h, 5c00h, 6600h, 7000h ;01 - F9 <79>
       7000
 FDF2  4D00 4D00 7400		        dw	4d00h, 4d00h, 7400h, 9d00h ;74 - (E0)RIGHT <80>
       9D00
 FDFA  4800 4800 8D00		        dw	4800h, 4800h, 8d00h, 9800h ;75 - (E0)UP <81>
       9800
 FE02  011B 011B 011B		        dw	011bh, 011bh, 011bh, 0100h ;76 - ESC <82>
       0100
 FE0A  8500 8700 8900		        dw	8500h, 8700h, 8900h, 8b00h ;78 - F11 <83>
       8B00
 FE12  4E2B 4E2B 9000		        dw	4e2bh, 4e2bh, 9000h, 4e00h ;79 - KP+ <84>
       4E00
 FE1A  5100 5100 7600		        dw	5100h, 5100h, 7600h, 0a100h ;7a - (E0)PGDN <85>
       A100
 FE22  4A2D 4A2D 8E00		        dw	4a2dh, 4a2dh, 8e00h, 4a00h ;7b - KP- <86>
       4A00
 FE2A  372A 372A 9600		        dw	372ah, 372ah, 9600h, 3700h ;7c - KP* --- on VMWare, it does not send 3710h with CTL <87>
       3700
 FE32  4900 4900 8400		        dw	4900h, 4900h, 8400h, 9900h ;7d - (E0)PGUP <88>
       9900
 FE3A  4600 4600 4600		        dw	4600h, 4600h, 4600h, 4600h ;7e - SCRL <89>
       4600
 FE42  4100 5A00 6400		        dw	4100h, 5a00h, 6400h, 6e00h ;83 - F7 <90>
       6E00

				; ------------------------- POWER ON RESET -----------------------
				        org     0fff0h
				        
 FFF0  EA			        db      0eah
 FFF1  E05B R F000		        dw      coldboot, 0f000h
 FFF5  31 37 2F 30 33 2F	        db      '17/03/14'
       31 34
 FFFD  FF FF 00			        db      0ffh, 0ffh, 0
				end bios
Microsoft (R) Macro Assembler Version 6.14.8444		    04/14/17 11:32:11
BIOS_Next186.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

OFFDX  . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_TEXT  . . . . . . . . . . . . .	16 Bit	 00010000 Word	  Public  'CODE'	
_DATA  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

KeyLock  . . . . . . . . . . . .	P Near	 E56B	  _TEXT	Length= 0016 Public
  s2 . . . . . . . . . . . . . .	L Near	 E578	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 E580	  _TEXT	
defint . . . . . . . . . . . . .	P Near	 F54B	  _TEXT	Length= 0001 Public
enableKbIfPresent  . . . . . . .	P Near	 F53F	  _TEXT	Length= 000C Public
  noenablekb . . . . . . . . . .	L Near	 F54A	  _TEXT	
getps2byte . . . . . . . . . . .	P Near	 F514	  _TEXT	Length= 001A Public
  gps2b2 . . . . . . . . . . . .	L Near	 F519	  _TEXT	
  gps2b1 . . . . . . . . . . . .	L Near	 F529	  _TEXT	
int07  . . . . . . . . . . . . .	P Near	 E2EC	  _TEXT	Length= 0030 Public
  int07_pfx  . . . . . . . . . .	L Near	 E2F5	  _TEXT	
  int072 . . . . . . . . . . . .	L Near	 E30E	  _TEXT	
int08  . . . . . . . . . . . . .	P Near	 E31C	  _TEXT	Length= 0046 Public
  int081 . . . . . . . . . . . .	L Near	 E344	  _TEXT	
  kloop  . . . . . . . . . . . .	L Near	 E34A	  _TEXT	
  kbdata . . . . . . . . . . . .	L Near	 E35C	  _TEXT	
  nokey  . . . . . . . . . . . .	L Near	 E35E	  _TEXT	
int09  . . . . . . . . . . . . .	P Near	 E362	  _TEXT	Length= 0209 Public
  SecondACK  . . . . . . . . . .	L Near	 E38C	  _TEXT	
  ToggleACK  . . . . . . . . . .	L Near	 E38F	  _TEXT	
  SetFlags1  . . . . . . . . . .	L Near	 E392	  _TEXT	
  noACK  . . . . . . . . . . . .	L Near	 E395	  _TEXT	
  noE0 . . . . . . . . . . . . .	L Near	 E3A8	  _TEXT	
  noE1 . . . . . . . . . . . . .	L Near	 E3B1	  _TEXT	
  noDEL  . . . . . . . . . . . .	L Near	 E3CD	  _TEXT	
  noLSDown . . . . . . . . . . .	L Near	 E3DB	  _TEXT	
  noLSUp . . . . . . . . . . . .	L Near	 E3E4	  _TEXT	
  noRSDown . . . . . . . . . . .	L Near	 E3ED	  _TEXT	
  noRSUp . . . . . . . . . . . .	L Near	 E3F6	  _TEXT	
  LALTDn . . . . . . . . . . . .	L Near	 E407	  _TEXT	
  noALTDown  . . . . . . . . . .	L Near	 E40D	  _TEXT	
  LALTUp . . . . . . . . . . . .	L Near	 E41E	  _TEXT	
  ALTUp  . . . . . . . . . . . .	L Near	 E422	  _TEXT	
  noALTUp  . . . . . . . . . . .	L Near	 E42F	  _TEXT	
  SetFlagsKey2 . . . . . . . . .	L Near	 E43E	  _TEXT	
  LCTLDn . . . . . . . . . . . .	L Near	 E440	  _TEXT	
  noCTLDown  . . . . . . . . . .	L Near	 E446	  _TEXT	
  LCTLUp . . . . . . . . . . . .	L Near	 E457	  _TEXT	
  noCTLUp  . . . . . . . . . . .	L Near	 E45D	  _TEXT	
  noScrLock  . . . . . . . . . .	L Near	 E490	  _TEXT	
  testINS  . . . . . . . . . . .	L Near	 E49F	  _TEXT	
  noIns  . . . . . . . . . . . .	L Near	 E4A5	  _TEXT	
  SetFlagsKey1 . . . . . . . . .	L Near	 E4B9	  _TEXT	
  E0Key  . . . . . . . . . . . .	L Near	 E4BC	  _TEXT	
  NormalKey  . . . . . . . . . .	L Near	 E4D1	  _TEXT	
  KeyDown  . . . . . . . . . . .	L Near	 E4E5	  _TEXT	
  noShift  . . . . . . . . . . .	L Near	 E4EE	  _TEXT	
  noCaps . . . . . . . . . . . .	L Near	 E4FC	  _TEXT	
  NumDown  . . . . . . . . . . .	L Near	 E507	  _TEXT	
  noNum  . . . . . . . . . . . .	L Near	 E50A	  _TEXT	
  noCtrl . . . . . . . . . . . .	L Near	 E511	  _TEXT	
  noAlt  . . . . . . . . . . . .	L Near	 E518	  _TEXT	
  pushKey  . . . . . . . . . . .	L Near	 E536	  _TEXT	
  SetFlagsKey  . . . . . . . . .	L Near	 E541	  _TEXT	
  SetFlags . . . . . . . . . . .	L Near	 E544	  _TEXT	
  SF1  . . . . . . . . . . . . .	L Near	 E55F	  _TEXT	
  int09Exit  . . . . . . . . . .	L Near	 E567	  _TEXT	
int10  . . . . . . . . . . . . .	P Near	 E581	  _TEXT	Length= 083B Public
  exit . . . . . . . . . . . . .	L Near	 E5A0	  _TEXT	
  svga . . . . . . . . . . . . .	L Near	 E5A3	  _TEXT	
  VESAGetInfo  . . . . . . . . .	L Near	 E5B8	  _TEXT	
  VESASupportedClear . . . . . .	L Near	 E5C5	  _TEXT	
  VESASupported  . . . . . . . .	L Near	 E5CB	  _TEXT	
  VESASupportedErr . . . . . . .	L Near	 E5CD	  _TEXT	
  VESAGetModeInfo  . . . . . . .	L Near	 E5D1	  _TEXT	
  VESAGetModeInfo1 . . . . . . .	L Near	 E5D5	  _TEXT	
  VESASetMode  . . . . . . . . .	L Near	 E5E8	  _TEXT	
  VESASetMode1 . . . . . . . . .	L Near	 E5FA	  _TEXT	
  VESAGetMode  . . . . . . . . .	L Near	 E602	  _TEXT	
  VESAGetMode1 . . . . . . . . .	L Near	 E618	  _TEXT	
  VESAMemControl . . . . . . . .	L Near	 E61E	  _TEXT	
  VESAMemControlCB . . . . . . .	L Near	 E622	  _TEXT	
  getpageinfo  . . . . . . . . .	L Near	 E63F	  _TEXT	
  VESAModeInfo . . . . . . . . .	L Near	 E675	  _TEXT	
  setmode  . . . . . . . . . . .	L Near	 E687	  _TEXT	
  setmode1 . . . . . . . . . . .	L Near	 E6E8	  _TEXT	
  setmode12  . . . . . . . . . .	L Near	 E6FF	  _TEXT	
  setmode121 . . . . . . . . . .	L Near	 E714	  _TEXT	
  setmode13  . . . . . . . . . .	L Near	 E723	  _TEXT	
  setmode3 . . . . . . . . . . .	L Near	 E73A	  _TEXT	
  setmode21  . . . . . . . . . .	L Near	 E752	  _TEXT	
  setmode2 . . . . . . . . . . .	L Near	 E75A	  _TEXT	
  clearnext  . . . . . . . . . .	L Near	 E78A	  _TEXT	
  clearok  . . . . . . . . . . .	L Near	 E79E	  _TEXT	
  setmode4 . . . . . . . . . . .	L Near	 E7A5	  _TEXT	
  setmodeexit  . . . . . . . . .	L Near	 E7D7	  _TEXT	
  nullproc . . . . . . . . . . .	L Near	 E7D9	  _TEXT	
  cursor . . . . . . . . . . . .	L Near	 E7DA	  _TEXT	
  curpos . . . . . . . . . . . .	L Near	 E7F3	  _TEXT	
  curpos1  . . . . . . . . . . .	L Near	 E825	  _TEXT	
  getcurpos  . . . . . . . . . .	L Near	 E828	  _TEXT	
  lightpen . . . . . . . . . . .	L Near	 E838	  _TEXT	
  apage  . . . . . . . . . . . .	L Near	 E83B	  _TEXT	
  apage1 . . . . . . . . . . . .	L Near	 E866	  _TEXT	
  apage3 . . . . . . . . . . . .	L Near	 E874	  _TEXT	
  apage2 . . . . . . . . . . . .	L Near	 E876	  _TEXT	
  apage4 . . . . . . . . . . . .	L Near	 E879	  _TEXT	
  scrollup . . . . . . . . . . .	L Near	 E894	  _TEXT	
  scrollup6  . . . . . . . . . .	L Near	 E89E	  _TEXT	
  scrollup4  . . . . . . . . . .	L Near	 E8B5	  _TEXT	
  scrollup3  . . . . . . . . . .	L Near	 E8C2	  _TEXT	
  scrollup5  . . . . . . . . . .	L Near	 E8C7	  _TEXT	
  scrollexit . . . . . . . . . .	L Near	 E8D1	  _TEXT	
  scrolldn . . . . . . . . . . .	L Near	 E8D4	  _TEXT	
  scr_params . . . . . . . . . .	L Near	 E8E5	  _TEXT	
  readchar . . . . . . . . . . .	L Near	 E8FB	  _TEXT	
  mode3chaddr  . . . . . . . . .	L Near	 E903	  _TEXT	
  writecharattr  . . . . . . . .	L Near	 E921	  _TEXT	
  writechar  . . . . . . . . . .	L Near	 E937	  _TEXT	
  writechar3 . . . . . . . . . .	L Near	 E93E	  _TEXT	
  writecharskip  . . . . . . . .	L Near	 E947	  _TEXT	
  writecharTTY . . . . . . . . .	L Near	 E948	  _TEXT	
  tty  . . . . . . . . . . . . .	L Near	 E966	  _TEXT	
  tty1 . . . . . . . . . . . . .	L Near	 E98B	  _TEXT	
  bell . . . . . . . . . . . . .	L Near	 E98D	  _TEXT	
  bs . . . . . . . . . . . . . .	L Near	 E98F	  _TEXT	
  lf . . . . . . . . . . . . . .	L Near	 E997	  _TEXT	
  crlf . . . . . . . . . . . . .	L Near	 E99B	  _TEXT	
  cr . . . . . . . . . . . . . .	L Near	 E99D	  _TEXT	
  readmode . . . . . . . . . . .	L Near	 E9BF	  _TEXT	
  pal  . . . . . . . . . . . . .	L Near	 EA09	  _TEXT	
  palexit  . . . . . . . . . . .	L Near	 EA24	  _TEXT	
  palpage  . . . . . . . . . . .	L Near	 EA25	  _TEXT	
  palpageset . . . . . . . . . .	L Near	 EA2B	  _TEXT	
  page16 . . . . . . . . . . . .	L Near	 EA3E	  _TEXT	
  palpage1 . . . . . . . . . . .	L Near	 EA41	  _TEXT	
  palpageexit  . . . . . . . . .	L Near	 EA63	  _TEXT	
  setonereg  . . . . . . . . . .	L Near	 EA64	  _TEXT	
  setonereg1 . . . . . . . . . .	L Near	 EA7E	  _TEXT	
  setallreg  . . . . . . . . . .	L Near	 EA7F	  _TEXT	
  setallreg1 . . . . . . . . . .	L Near	 EA86	  _TEXT	
  setblink . . . . . . . . . . .	L Near	 EA93	  _TEXT	
  setblink1  . . . . . . . . . .	L Near	 EAB6	  _TEXT	
  readonereg . . . . . . . . . .	L Near	 EAB8	  _TEXT	
  readonereg1  . . . . . . . . .	L Near	 EAEA	  _TEXT	
  readallreg . . . . . . . . . .	L Near	 EAEB	  _TEXT	
  readllreg1 . . . . . . . . . .	L Near	 EAF0	  _TEXT	
  readoverscan . . . . . . . . .	L Near	 EB02	  _TEXT	
  setoneDAC  . . . . . . . . . .	L Near	 EB05	  _TEXT	
  setblockDAC  . . . . . . . . .	L Near	 EB1B	  _TEXT	
  paging . . . . . . . . . . . .	L Near	 EB2C	  _TEXT	
  paging1  . . . . . . . . . . .	L Near	 EB3B	  _TEXT	
  paging2  . . . . . . . . . . .	L Near	 EB41	  _TEXT	
  readoneDAC . . . . . . . . . .	L Near	 EB47	  _TEXT	
  readblockDAC . . . . . . . . .	L Near	 EB5F	  _TEXT	
  setPELmask . . . . . . . . . .	L Near	 EB70	  _TEXT	
  getPELmask . . . . . . . . . .	L Near	 EB79	  _TEXT	
  getpaging  . . . . . . . . . .	L Near	 EB82	  _TEXT	
  grayscale  . . . . . . . . . .	L Near	 EB8D	  _TEXT	
  grayscale1 . . . . . . . . . .	L Near	 EB92	  _TEXT	
  grayscale2 . . . . . . . . . .	L Near	 EBBA	  _TEXT	
  colfrombits  . . . . . . . . .	L Near	 EBBB	  _TEXT	
  col1 . . . . . . . . . . . . .	L Near	 EBC8	  _TEXT	
  loadUDF  . . . . . . . . . . .	L Near	 EBC9	  _TEXT	
  loadUDFexit  . . . . . . . . .	L Near	 EBDE	  _TEXT	
  chargen  . . . . . . . . . . .	L Near	 EBDF	  _TEXT	
  loadROMFont  . . . . . . . . .	L Near	 EC02	  _TEXT	
  set1f  . . . . . . . . . . . .	L Near	 EC16	  _TEXT	
  setgrUDF . . . . . . . . . . .	L Near	 EC21	  _TEXT	
  setgrUDF1  . . . . . . . . . .	L Near	 EC41	  _TEXT	
  setgrUDFexit . . . . . . . . .	L Near	 EC4C	  _TEXT	
  setROMgrFont . . . . . . . . .	L Near	 EC4E	  _TEXT	
  setROMgrFont1  . . . . . . . .	L Near	 EC5F	  _TEXT	
  getfontinfo  . . . . . . . . .	L Near	 EC6C	  _TEXT	
  getfontinfo1 . . . . . . . . .	L Near	 EC87	  _TEXT	
  getfontinfoexit  . . . . . . .	L Near	 EC9A	  _TEXT	
  special  . . . . . . . . . . .	L Near	 ECA7	  _TEXT	
  special1 . . . . . . . . . . .	L Near	 ECB7	  _TEXT	
  special2 . . . . . . . . . . .	L Near	 ECCB	  _TEXT	
  writestr . . . . . . . . . . .	L Near	 ECCE	  _TEXT	
  wstr1  . . . . . . . . . . . .	L Near	 ECDD	  _TEXT	
  noattr . . . . . . . . . . . .	L Near	 ECEB	  _TEXT	
  wstr2  . . . . . . . . . . . .	L Near	 ED00	  _TEXT	
  wstrexit . . . . . . . . . . .	L Near	 ED01	  _TEXT	
  getdcc . . . . . . . . . . . .	L Near	 ED02	  _TEXT	
  setdcc . . . . . . . . . . . .	L Near	 ED0D	  _TEXT	
  getdccexit . . . . . . . . . .	L Near	 ED12	  _TEXT	
  querystatus  . . . . . . . . .	L Near	 ED13	  _TEXT	
  querystatus1 . . . . . . . . .	L Near	 ED45	  _TEXT	
  querystatus3 . . . . . . . . .	L Near	 ED4F	  _TEXT	
int11  . . . . . . . . . . . . .	P Near	 EDBC	  _TEXT	Length= 0009 Public
int12  . . . . . . . . . . . . .	P Near	 EDC5	  _TEXT	Length= 0009 Public
int13  . . . . . . . . . . . . .	P Near	 EDCE	  _TEXT	Length= 01ED Public
  inINT13  . . . . . . . . . . .	L Near	 EDED	  _TEXT	
  Disk1  . . . . . . . . . . . .	L Near	 EDF1	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 EE01	  _TEXT	
  exit2  . . . . . . . . . . . .	L Near	 EE05	  _TEXT	
  exit1  . . . . . . . . . . . .	L Near	 EE0C	  _TEXT	
  DiskGetType  . . . . . . . . .	L Near	 EE5F	  _TEXT	
  DiskGetTypeexit  . . . . . . .	L Near	 EE76	  _TEXT	
  DiskExtInstCheck . . . . . . .	L Near	 EE7F	  _TEXT	
  DiskReset  . . . . . . . . . .	L Near	 EE8D	  _TEXT	
  DiskChanged  . . . . . . . . .	L Near	 EE8D	  _TEXT	
  DiskPark . . . . . . . . . . .	L Near	 EE8D	  _TEXT	
  DiskGetStatus  . . . . . . . .	L Near	 EE90	  _TEXT	
  DiskVerify . . . . . . . . . .	L Near	 EE95	  _TEXT	
  DiskWrite  . . . . . . . . . .	L Near	 EE9A	  _TEXT	
  DiskRead . . . . . . . . . . .	L Near	 EE9F	  _TEXT	
  DiskRead1  . . . . . . . . . .	L Near	 EEA2	  _TEXT	
  DiskReadend  . . . . . . . . .	L Near	 EECA	  _TEXT	
  HCStoLBA . . . . . . . . . . .	L Near	 EECB	  _TEXT	
  DiskFormat . . . . . . . . . .	L Near	 EEE9	  _TEXT	
  DiskInit . . . . . . . . . . .	L Near	 EEE9	  _TEXT	
  DiskSeek . . . . . . . . . . .	L Near	 EEE9	  _TEXT	
  DiskRst  . . . . . . . . . . .	L Near	 EEE9	  _TEXT	
  DiskReady  . . . . . . . . . .	L Near	 EEE9	  _TEXT	
  DiskRecalibrate  . . . . . . .	L Near	 EEE9	  _TEXT	
  DiskDiag . . . . . . . . . . .	L Near	 EEE9	  _TEXT	
  DiskExtSeek  . . . . . . . . .	L Near	 EEE9	  _TEXT	
  notready . . . . . . . . . . .	L Near	 EEF5	  _TEXT	
  DiskGetParams  . . . . . . . .	L Near	 EEF8	  _TEXT	
  dgpok  . . . . . . . . . . . .	L Near	 EF20	  _TEXT	
  DiskExtVerify  . . . . . . . .	L Near	 EF2F	  _TEXT	
  DiskExtWrite . . . . . . . . .	L Near	 EF34	  _TEXT	
  DiskExtRead  . . . . . . . . .	L Near	 EF39	  _TEXT	
  DiskExtRead1 . . . . . . . . .	L Near	 EF3C	  _TEXT	
  DiskExtGetParams . . . . . . .	L Near	 EF6B	  _TEXT	
  DiskReadSectBuffer . . . . . .	L Near	 EFB8	  _TEXT	
  DiskWriteSectBuffer  . . . . .	L Near	 EFB8	  _TEXT	
  DiskSetDASDType  . . . . . . .	L Near	 EFB8	  _TEXT	
  DiskSetMediaType . . . . . . .	L Near	 EFB8	  _TEXT	
  DiskExtLock  . . . . . . . . .	L Near	 EFB8	  _TEXT	
  DiskExtEject . . . . . . . . .	L Near	 EFB8	  _TEXT	
int14  . . . . . . . . . . . . .	P Near	 EFBB	  _TEXT	Length= 0081 Public
  SExit  . . . . . . . . . . . .	L Near	 EFE2	  _TEXT	
  SetCharFormat  . . . . . . . .	L Near	 EFE6	  _TEXT	
  Baud110  . . . . . . . . . . .	L Near	 EFFF	  _TEXT	
  GetPortStatus  . . . . . . . .	L Near	 F015	  _TEXT	
  GetPortStatus1 . . . . . . . .	L Near	 F018	  _TEXT	
  STransmit  . . . . . . . . . .	L Near	 F01F	  _TEXT	
  STr1 . . . . . . . . . . . . .	L Near	 F022	  _TEXT	
  STr2 . . . . . . . . . . . . .	L Near	 F02D	  _TEXT	
  SReceive . . . . . . . . . . .	L Near	 F030	  _TEXT	
  SReceive1  . . . . . . . . . .	L Near	 F031	  _TEXT	
int16  . . . . . . . . . . . . .	P Near	 F2A4	  _TEXT	Length= 00EB Public
  kbfunc . . . . . . . . . . . .	L Near	 F2CC	  _TEXT	
  Exit . . . . . . . . . . . . .	L Near	 F2CE	  _TEXT	
  GetKey1  . . . . . . . . . . .	L Near	 F2D1	  _TEXT	
  GetKey . . . . . . . . . . . .	L Near	 F2D2	  _TEXT	
  noWrap . . . . . . . . . . . .	L Near	 F2E8	  _TEXT	
  TestKey  . . . . . . . . . . .	L Near	 F2EE	  _TEXT	
  StoreKey . . . . . . . . . . .	L Near	 F2FD	  _TEXT	
  NoWrap1  . . . . . . . . . . .	L Near	 F30F	  _TEXT	
  ExtStatus  . . . . . . . . . .	L Near	 F31E	  _TEXT	
  NoSysReq . . . . . . . . . . .	L Near	 F329	  _TEXT	
  GetStatus  . . . . . . . . . .	L Near	 F332	  _TEXT	
  Exit1  . . . . . . . . . . . .	L Near	 F335	  _TEXT	
  SetAutoRpt . . . . . . . . . .	L Near	 F337	  _TEXT	
  timeout1 . . . . . . . . . . .	L Near	 F36D	  _TEXT	
  timeout  . . . . . . . . . . .	L Near	 F372	  _TEXT	
  WaitFlag . . . . . . . . . . .	L Near	 F375	  _TEXT	
  wf_loop  . . . . . . . . . . .	L Near	 F37A	  _TEXT	
  wf_ok  . . . . . . . . . . . .	L Near	 F38E	  _TEXT	
int18  . . . . . . . . . . . . .	P Near	 F38F	  _TEXT	Length= 007F Public
  sloop  . . . . . . . . . . . .	L Near	 F3B9	  _TEXT	
int19  . . . . . . . . . . . . .	P Near	 F40E	  _TEXT	Length= 001A Public
  int19err . . . . . . . . . . .	L Near	 F426	  _TEXT	
int1a  . . . . . . . . . . . . .	P Near	 F428	  _TEXT	Length= 002C Public
  clockexit1 . . . . . . . . . .	L Near	 F43E	  _TEXT	
  clockexit  . . . . . . . . . .	L Near	 F443	  _TEXT	
  setclock . . . . . . . . . . .	L Near	 F449	  _TEXT	
int70  . . . . . . . . . . . . .	P Near	 F454	  _TEXT	Length= 0028 Public
  exit . . . . . . . . . . . . .	L Near	 F47A	  _TEXT	
int74  . . . . . . . . . . . . .	P Near	 F47C	  _TEXT	Length= 0047 Public
  docall . . . . . . . . . . . .	L Near	 F4A1	  _TEXT	
  nocall . . . . . . . . . . . .	L Near	 F4C0	  _TEXT	
sdinit . . . . . . . . . . . . .	P Near	 F73A	  _TEXT	Length= 009D Public
  sdinit1  . . . . . . . . . . .	L Near	 F745	  _TEXT	
  repinit  . . . . . . . . . . .	L Near	 F775	  _TEXT	
  sdexit . . . . . . . . . . . .	L Near	 F7C9	  _TEXT	
sdrblk . . . . . . . . . . . . .	P Near	 F5E4	  _TEXT	Length= 0030 Public
  sdrblk1  . . . . . . . . . . .	L Near	 F5EC	  _TEXT	
  sdrblk2  . . . . . . . . . . .	L Near	 F5F1	  _TEXT	
sdwblk . . . . . . . . . . . . .	P Near	 F5B1	  _TEXT	Length= 0033 Public
  sdwblk1  . . . . . . . . . . .	L Near	 F5B3	  _TEXT	
sendcmd  . . . . . . . . . . . .	P Near	 F52E	  _TEXT	Length= 0011 Public
  retry  . . . . . . . . . . . .	L Near	 F535	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 F53E	  _TEXT	
sendps2byte  . . . . . . . . . .	P Near	 F4EF	  _TEXT	Length= 0025 Public
  sps2b2 . . . . . . . . . . . .	L Near	 F4F5	  _TEXT	
  sps2b1 . . . . . . . . . . . .	L Near	 F506	  _TEXT	
  sps2_kb  . . . . . . . . . . .	L Near	 F50E	  _TEXT	
  exit . . . . . . . . . . . . .	L Near	 F512	  _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0001h	 
@code  . . . . . . . . . . . . .	Text   	 DGROUP
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
AckReceived  . . . . . . . . . .	Number	 0010h	 
ActivePage . . . . . . . . . . .	Text   	 ds:[62h]
ActiveVideoMode  . . . . . . . .	Text   	 ds:[49h]
AltDown  . . . . . . . . . . . .	Number	 0008h	 
AltKpd . . . . . . . . . . . . .	Text   	 ds:[19h]
Buffer . . . . . . . . . . . . .	Text   	 ds:[80h]
CapsLockDown . . . . . . . . . .	Number	 0040h	 
CapsLockLED  . . . . . . . . . .	Number	 0004h	 
CapsLock . . . . . . . . . . . .	Number	 0040h	 
ComPort  . . . . . . . . . . . .	Number	 0000h	 
CrtMode  . . . . . . . . . . . .	Text   	 ds:[65h]
CrtPalette . . . . . . . . . . .	Text   	 ds:[66h]
CtrlBreak  . . . . . . . . . . .	Text   	 ds:[71h]
CtrlDown . . . . . . . . . . . .	Number	 0004h	 
CursorPos  . . . . . . . . . . .	Text   	 ds:[50h]
CursorShape  . . . . . . . . . .	Text   	 ds:[60h]
DLH  . . . . . . . . . . . . . .	Number	 0001h	 
DLL  . . . . . . . . . . . . . .	Number	 0000h	 
DataBuffer . . . . . . . . . . .	Text   	 ds:[0a5h]
DataCounter  . . . . . . . . . .	Text   	 ds:[067h]
E0KeyIndex . . . . . . . . . . .	L Near	 FB66	  _TEXT	
E0KeyList  . . . . . . . . . . .	L Near	 FB5A	  _TEXT	
EgaMiscInfo2 . . . . . . . . . .	Text   	 ds:[88h]
EgaMiscInfo  . . . . . . . . . .	Text   	 ds:[87h]
EndBuf . . . . . . . . . . . . .	Text   	 ds:[82h]
EquipmentWord  . . . . . . . . .	Text   	 ds:[10h]
ExtSize  . . . . . . . . . . . .	L Near	 F194	  _TEXT	
FreeXMSKb  . . . . . . . . . . .	Number	 3B60h	 
GetConfig  . . . . . . . . . . .	L Near	 F199	  _TEXT	
HDLastError  . . . . . . . . . .	Text   	 ds:[74h]
HDOpStarted  . . . . . . . . . .	Text   	 ds:[92h]
HDSize . . . . . . . . . . . . .	Text   	 ds:[94h]
HandlerPtr . . . . . . . . . . .	Text   	 ds:[0a1h]
HeadPtr  . . . . . . . . . . . .	Text   	 ds:[1ah]
IER  . . . . . . . . . . . . . .	Number	 0001h	 
IncSeg1  . . . . . . . . . . . .	L Near	 F04A	  _TEXT	
IncSeg . . . . . . . . . . . . .	L Near	 F03C	  _TEXT	
InsDown  . . . . . . . . . . . .	Number	 0080h	 
Insert . . . . . . . . . . . . .	Number	 0080h	 
KbdFlags1  . . . . . . . . . . .	Text   	 ds:[17h]
KbdFlags2  . . . . . . . . . . .	Text   	 ds:[18h]
KbdFlags3  . . . . . . . . . . .	Text   	 ds:[96h]
KbdFlags4  . . . . . . . . . . .	Text   	 ds:[97h]
KeyCode  . . . . . . . . . . . .	L Near	 FB72	  _TEXT	
KeyIndex . . . . . . . . . . . .	L Near	 FB01	  _TEXT	
LAltDown . . . . . . . . . . . .	Number	 0002h	 
LCR  . . . . . . . . . . . . . .	Number	 0003h	 
LCtrDown . . . . . . . . . . . .	Number	 0001h	 
LEDUpdate  . . . . . . . . . . .	Number	 0040h	 
LSR  . . . . . . . . . . . . . .	Number	 0005h	 
LShfDown . . . . . . . . . . . .	Number	 0002h	 
LastE0 . . . . . . . . . . . . .	Number	 0002h	 
LastE1 . . . . . . . . . . . . .	Number	 0001h	 
LastF0 . . . . . . . . . . . . .	Number	 0020h	 
MSR  . . . . . . . . . . . . . .	Number	 0006h	 
MemorySize . . . . . . . . . . .	Text   	 ds:[13h]
Mouse  . . . . . . . . . . . . .	L Near	 F1A2	  _TEXT	
MovExt1  . . . . . . . . . . . .	L Near	 F0B6	  _TEXT	
MovExt2  . . . . . . . . . . . .	L Near	 F0C8	  _TEXT	
MovExtLoop . . . . . . . . . . .	L Near	 F0AD	  _TEXT	
MovExtProxy  . . . . . . . . . .	L Near	 F109	  _TEXT	
MovExt_exit  . . . . . . . . . .	L Near	 F0F1	  _TEXT	
MovExt_next  . . . . . . . . . .	L Near	 F0DB	  _TEXT	
MovExt . . . . . . . . . . . . .	L Near	 F06A	  _TEXT	
MovSeg . . . . . . . . . . . . .	Number	 0001h	 
NumLockDown  . . . . . . . . . .	Number	 0020h	 
NumLockLED . . . . . . . . . . .	Number	 0002h	 
NumLock  . . . . . . . . . . . .	Number	 0020h	 
PacketSize . . . . . . . . . . .	Text   	 ds:[068h]
PageOffset . . . . . . . . . . .	Text   	 ds:[4eh]
PalPagingCounter . . . . . . . .	Text   	 ds:[6ah]
PalPaging  . . . . . . . . . . .	Text   	 ds:[69h]
Pause  . . . . . . . . . . . . .	Number	 0008h	 
PortAddress  . . . . . . . . . .	Text   	 ds:[63h]
RAMSize  . . . . . . . . . . . .	Number	 0100h	 
RAltDown . . . . . . . . . . . .	Number	 0008h	 
RBR  . . . . . . . . . . . . . .	Number	 0000h	 
RCtrDown . . . . . . . . . . . .	Number	 0004h	 
RShfDown . . . . . . . . . . . .	Number	 0001h	 
RegenLength  . . . . . . . . . .	Text   	 ds:[4ch]
SCANCODE1  . . . . . . . . . . .	Number	 0001h	 
SD_CMD0  . . . . . . . . . . . .	Byte	 F7D7	  _TEXT	
SD_CMD12 . . . . . . . . . . . .	Byte	 F7E9	  _TEXT	
SD_CMD41 . . . . . . . . . . . .	Byte	 F7EF	  _TEXT	
SD_CMD55 . . . . . . . . . . . .	Byte	 F7F5	  _TEXT	
SD_CMD58 . . . . . . . . . . . .	Byte	 F7FB	  _TEXT	
SD_CMD8  . . . . . . . . . . . .	Byte	 F7DD	  _TEXT	
SD_CMD9  . . . . . . . . . . . .	Byte	 F7E3	  _TEXT	
ScanLinesChar  . . . . . . . . .	Text   	 ds:[85h]
ScrLockDown  . . . . . . . . . .	Number	 0010h	 
ScrLockLED . . . . . . . . . . .	Number	 0001h	 
ScrLock  . . . . . . . . . . . .	Number	 0010h	 
ScreenRows . . . . . . . . . . .	Text   	 ds:[84h]
ScreenWidth  . . . . . . . . . .	Text   	 ds:[4ah]
SetEventWait . . . . . . . . . .	L Near	 F146	  _TEXT	
SetRepeat  . . . . . . . . . . .	Number	 0008h	 
SetSeg1  . . . . . . . . . . . .	L Near	 F062	  _TEXT	
SetSeg2  . . . . . . . . . . . .	L Near	 F05A	  _TEXT	
SetSegExit . . . . . . . . . . .	L Near	 F063	  _TEXT	
SetSeg . . . . . . . . . . . . .	L Near	 F04F	  _TEXT	
SysParams  . . . . . . . . . . .	Byte	 F29A	  _TEXT	
SysReqDown . . . . . . . . . . .	Number	 0004h	 
THR  . . . . . . . . . . . . . .	Number	 0000h	 
TailPtr  . . . . . . . . . . . .	Text   	 ds:[1ch]
UFPtr  . . . . . . . . . . . . .	Text   	 ds:[98h]
UWaitFlag  . . . . . . . . . . .	Text   	 ds:[0a0h]
VESAInfo . . . . . . . . . . . .	Byte	 E64A	  _TEXT	
VESAModes  . . . . . . . . . . .	Word	 E671	  _TEXT	
VESAOEM  . . . . . . . . . . . .	Byte	 E65E	  _TEXT	
VgaFlags2  . . . . . . . . . . .	Text   	 ds:[8ah]
VgaFlags . . . . . . . . . . . .	Text   	 ds:[89h]
Wait1  . . . . . . . . . . . . .	L Near	 F17B	  _TEXT	
WaitCount  . . . . . . . . . . .	Text   	 ds:[9ch]
badparam . . . . . . . . . . . .	L Near	 F227	  _TEXT	
bioscont . . . . . . . . . . . .	Byte	 E26E	  _TEXT	
biosmsg  . . . . . . . . . . . .	Byte	 E000	  _TEXT	
bios . . . . . . . . . . . . . .	L Near	 E000	  _TEXT	
booterrmsg . . . . . . . . . . .	Byte	 F3C7	  _TEXT	
busy . . . . . . . . . . . . . .	L Near	 F177	  _TEXT	
cancel . . . . . . . . . . . . .	L Near	 F170	  _TEXT	
coldboot . . . . . . . . . . . .	L Near	 E05B	  _TEXT	
dccval . . . . . . . . . . . . .	Word	 ED0D	  _TEXT	
default_pal  . . . . . . . . . .	L Near	 F801	  _TEXT	
disktbl  . . . . . . . . . . . .	Word	 EE19	  _TEXT	
dispAX1  . . . . . . . . . . . .	L Near	 F580	  _TEXT	
dispAX . . . . . . . . . . . . .	L Near	 F571	  _TEXT	
dly1 . . . . . . . . . . . . . .	L Near	 F4E6	  _TEXT	
dlybit . . . . . . . . . . . . .	L Near	 F4E2	  _TEXT	
done . . . . . . . . . . . . . .	L Near	 F13D	  _TEXT	
en_dis . . . . . . . . . . . . .	L Near	 F1FA	  _TEXT	
errexit  . . . . . . . . . . . .	L Near	 F1B3	  _TEXT	
exit15 . . . . . . . . . . . . .	L Near	 F13E	  _TEXT	
exit_ax  . . . . . . . . . . . .	L Near	 F141	  _TEXT	
exit_iret  . . . . . . . . . . .	L Near	 F145	  _TEXT	
exit_success1  . . . . . . . . .	L Near	 F20F	  _TEXT	
exit_success . . . . . . . . . .	L Near	 F20A	  _TEXT	
exitok . . . . . . . . . . . . .	L Near	 F1B4	  _TEXT	
extend . . . . . . . . . . . . .	L Near	 F265	  _TEXT	
flush1 . . . . . . . . . . . . .	L Near	 F559	  _TEXT	
flush_nostack  . . . . . . . . .	L Near	 F551	  _TEXT	
flushbh  . . . . . . . . . . . .	Word	 F56F	  _TEXT	
flushret . . . . . . . . . . . .	Word	 F56D	  _TEXT	
flush  . . . . . . . . . . . . .	L Near	 F54C	  _TEXT	
font8x16 . . . . . . . . . . . .	L Near	 E056	  _TEXT	
font8x8  . . . . . . . . . . . .	L Near	 E056	  _TEXT	
fontinfo . . . . . . . . . . . .	Word	 EC9B	  _TEXT	
gettype  . . . . . . . . . . . .	L Near	 F24D	  _TEXT	
if_err1  . . . . . . . . . . . .	L Near	 F208	  _TEXT	
if_err . . . . . . . . . . . . .	L Near	 F1AE	  _TEXT	
int15  . . . . . . . . . . . . .	L Near	 F10C	  _TEXT	
kbi1 . . . . . . . . . . . . . .	L Near	 E176	  _TEXT	
kbi2 . . . . . . . . . . . . . .	L Near	 E185	  _TEXT	
kbok . . . . . . . . . . . . . .	L Near	 E1B9	  _TEXT	
l1 . . . . . . . . . . . . . . .	L Near	 F4D7	  _TEXT	
mapi1  . . . . . . . . . . . . .	L Near	 E0A4	  _TEXT	
mapi . . . . . . . . . . . . . .	L Near	 E09B	  _TEXT	
mouse_present  . . . . . . . . .	L Near	 F1C4	  _TEXT	
mousei0  . . . . . . . . . . . .	L Near	 E1C1	  _TEXT	
mousei1  . . . . . . . . . . . .	L Near	 E1CF	  _TEXT	
mouseok  . . . . . . . . . . . .	L Near	 E1EB	  _TEXT	
msgkb  . . . . . . . . . . . . .	Byte	 E044	  _TEXT	
msgmb  . . . . . . . . . . . . .	Byte	 E037	  _TEXT	
msgmouse . . . . . . . . . . . .	Byte	 E259	  _TEXT	
nokbmsg  . . . . . . . . . . . .	L Near	 E23E	  _TEXT	
nokb . . . . . . . . . . . . . .	L Near	 E1B4	  _TEXT	
nomousemsg . . . . . . . . . . .	L Near	 E24B	  _TEXT	
nomouse  . . . . . . . . . . . .	L Near	 E1E2	  _TEXT	
nowait . . . . . . . . . . . . .	L Near	 F178	  _TEXT	
paltable . . . . . . . . . . . .	Word	 E9D1	  _TEXT	
prtse  . . . . . . . . . . . . .	L Near	 F596	  _TEXT	
prts . . . . . . . . . . . . . .	L Near	 F58A	  _TEXT	
raligned . . . . . . . . . . . .	L Near	 F0D4	  _TEXT	
reset  . . . . . . . . . . . . .	L Near	 F213	  _TEXT	
resolution . . . . . . . . . . .	L Near	 F243	  _TEXT	
sample_tbl . . . . . . . . . . .	Byte	 F293	  _TEXT	
sampling . . . . . . . . . . . .	L Near	 F224	  _TEXT	
savesp . . . . . . . . . . . . .	Word	 F066	  _TEXT	
savess . . . . . . . . . . . . .	Word	 F064	  _TEXT	
sdcmd1 . . . . . . . . . . . . .	L Near	 F63B	  _TEXT	
sdcmd8T  . . . . . . . . . . . .	L Near	 F625	  _TEXT	
sdcmd  . . . . . . . . . . . . .	L Near	 F628	  _TEXT	
sdr11  . . . . . . . . . . . . .	L Near	 F6B0	  _TEXT	
sdr1s  . . . . . . . . . . . . .	L Near	 F650	  _TEXT	
sdr1 . . . . . . . . . . . . . .	L Near	 F6B1	  _TEXT	
sdr2 . . . . . . . . . . . . . .	L Near	 F6A7	  _TEXT	
sdr3 . . . . . . . . . . . . . .	L Near	 F69A	  _TEXT	
sdrb . . . . . . . . . . . . . .	L Near	 F597	  _TEXT	
sdread1  . . . . . . . . . . . .	L Near	 F644	  _TEXT	
sdread . . . . . . . . . . . . .	L Near	 F641	  _TEXT	
sdresp1  . . . . . . . . . . . .	L Near	 F630	  _TEXT	
sdresp . . . . . . . . . . . . .	L Near	 F62E	  _TEXT	
sdrms  . . . . . . . . . . . . .	L Near	 F671	  _TEXT	
sdsb . . . . . . . . . . . . . .	L Near	 F599	  _TEXT	
sdvblk1  . . . . . . . . . . . .	L Near	 F617	  _TEXT	
sdvblk . . . . . . . . . . . . .	L Near	 F614	  _TEXT	
sdverify . . . . . . . . . . . .	L Near	 F63C	  _TEXT	
sdw1s1 . . . . . . . . . . . . .	L Near	 F700	  _TEXT	
sdw1s  . . . . . . . . . . . . .	L Near	 F6C8	  _TEXT	
sdwms  . . . . . . . . . . . . .	L Near	 F6E9	  _TEXT	
sdwrite  . . . . . . . . . . . .	L Near	 F6BC	  _TEXT	
sdwwait1 . . . . . . . . . . . .	L Near	 F730	  _TEXT	
sdwwait  . . . . . . . . . . . .	L Near	 F719	  _TEXT	
send1c . . . . . . . . . . . . .	L Near	 F23D	  _TEXT	
send2c . . . . . . . . . . . . .	L Near	 F236	  _TEXT	
setscaling . . . . . . . . . . .	L Near	 F288	  _TEXT	
srecb  . . . . . . . . . . . . .	L Near	 F4C3	  _TEXT	
srstb  . . . . . . . . . . . . .	L Near	 F4CB	  _TEXT	
staticfunctable  . . . . . . . .	Byte	 ED72	  _TEXT	
ten  . . . . . . . . . . . . . .	Word	 F588	  _TEXT	
vidtbl . . . . . . . . . . . . .	Word	 ED82	  _TEXT	
warmboot . . . . . . . . . . . .	L Near	 E05B	  _TEXT	
wbusy  . . . . . . . . . . . . .	L Near	 F190	  _TEXT	
wloop  . . . . . . . . . . . . .	L Near	 F189	  _TEXT	

	   0 Warnings
	   0 Errors
